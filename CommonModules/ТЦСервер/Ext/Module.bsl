///////////////////////////////////////////////////////////////////////////////
// ДОКУМЕНТ ТЕСТ

// Создать документ фиксирующий факт выполнения сценария
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий
//
// Возвращаемое значение:
//  ДокументСсылка.ТЦТест - ссылка тест по выбранному сценарию
//
Функция СоздатьТест(Сценарий, ПараметрыВыполнения)
	
	Тест = Документы.ТЦТест.СоздатьДокумент();
	Тест.Дата = ТекущаяДата();
	Тест.НачалоСостояния = Тест.Дата;
	Тест.Описание	= Сценарий.Описание;
	Тест.Прерван	= Ложь;
	Тест.Завершен	= Ложь;
	Тест.Результат	= Перечисления.ТЦРезультатВыполнения.Неопределено;
	Тест.Состояние	= Перечисления.ТЦСостояние.Подготовка;
	Тест.Сценарий	= Сценарий.Наименование;
	Тест.СценарийСсылка	= Сценарий;
	
	Тест.ОбщееКоличествоОдновременноЗапускаемыхВРМ	= ПараметрыВыполнения.ОбщееКоличествоОдновременноЗапускаемыхВРМ;
	Тест.КоличествоОдновременноЗапускаемыхВРМАгента	= ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента;
	
	Тест.ТаймаутЗапускаКлиента	= Сценарий.ТаймаутЗапускаКлиента;
	Тест.ПопытокЗапускаКлиентов	= Сценарий.ПопытокЗапускаКлиентов;
	Тест.ТаймаутОпросаКлиента	= Сценарий.ТаймаутОпросаКлиента;
	Тест.ТаймаутЗагрузкиСценарияКлиентом = Сценарий.ТаймаутЗагрузкиСценарияКлиентом;
	Тест.ТаймаутВыполнения		= Сценарий.ТаймаутВыполнения;
	Тест.ТаймаутЗаписиРезультатов = Сценарий.ТаймаутЗаписиРезультатов;
	Тест.ТаймаутИнициализации	= Сценарий.ТаймаутИнициализации;
	Тест.ТаймаутПодготовки		= Сценарий.ТаймаутПодготовки;
	Тест.ТаймаутУдаленияДанных	= Сценарий.ТаймаутУдаленияДанных;
	Тест.ПаузаПослеЗапускаВРМ	= Сценарий.ПаузаПослеЗапускаВРМ;
	Тест.ВРМЗапущены		= Ложь;
	Тест.ТекущаяИтерация	= 1;
	
	Тест.НачальноеКоличествоПользователей	= ПараметрыВыполнения.НачальноеКоличествоПользователей;
	Если Тест.НачальноеКоличествоПользователей = 0 Тогда
		Тест.НачальноеКоличествоПользователей = Сценарий.Структура.Итог("Количество");
	КонецЕсли;
	
	Тест.НачальныйШагДозапускаПользователей = ПараметрыВыполнения.НачальныйШагДозапускаПользователей;
	Тест.КонечныйШагДозапускаПользователей	= ПараметрыВыполнения.КонечныйШагДозапускаПользователей;
	Тест.МаксимальноеКоличествоИтераций		= ПараметрыВыполнения.МаксимальноеКоличествоИтераций;
	Тест.КритическоеКоличествоОшибокИтерации= ПараметрыВыполнения.КритическоеКоличествоОшибокИтерации;
	Тест.КритическоеКоличествоОшибокТеста	= ПараметрыВыполнения.КритическоеКоличествоОшибокТеста;
	Тест.КоэффициентИнтенсивности			= ПараметрыВыполнения.КоэффициентИнтенсивности;
	Тест.ПороговыйAPDEX			= ПараметрыВыполнения.ПороговыйAPDEX;
	Тест.ЭтоДинамическийТест	= ПараметрыВыполнения.ЭтоДинамическийТест;
	Тест.РаспределятьПоКомпьютерамРавномерно = ПараметрыВыполнения.РаспределятьПоКомпьютерамРавномерно;
	Тест.АдресПубликации	= ПараметрыВыполнения.АдресПубликации;
	Тест.ЕстьРазделение		= ПараметрыВыполнения.ЕстьРазделение;
	
	Если ПараметрыВыполнения.ТаблицаРаспределения <> Неопределено Тогда
		
		Для Каждого СтрокаТаблицы Из ПараметрыВыполнения.ТаблицаРаспределения Цикл
			
			НоваяСтрока = Тест.ТаблицаРаспределения.Добавить();
			НоваяСтрока.Компьютер = СтрокаТаблицы.Компьютер;
			НоваяСтрока.Вес = СтрокаТаблицы.Вес;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Тест.ОбменДанными.Загрузка = Истина;
	Тест.Записать();
	
	Возврат Тест.Ссылка;
	
КонецФункции // СоздатьТест()

// Изменить содержимое документа ТЦТест
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест, изменяемый документ
//  ПриИзменении - Строка, имя функции изменяющий документ, которая принимает
//                 в качестве параметра объект документа
//  Параметры - ПроизвольноеЗначение, параметры ПриИзменении
//
Процедура ИзменитьТест(Тест, ПриИзменении, Параметры = Неопределено)
	
	Если Тест = Неопределено Тогда
		Возврат
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
		Блокировки = Новый БлокировкаДанных;
		Блокировка = Блокировки.Добавить("Документ.ТЦТест");
		Блокировка.УстановитьЗначение("Ссылка", Тест);
		Блокировки.Заблокировать();
	КонецЕсли;
	
	ТестОбъект = Тест.ПолучитьОбъект();
	Параметр = ?(Параметры = Неопределено, "", ", Параметры");
	Выполнить ПриИзменении + "(ТестОбъект" + Параметр + ")";
	ТестОбъект.ОбменДанными.Загрузка = Истина;
	ТестОбъект.Записать();
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ИзменитьТест()

// Добавляет структуру текущей итерации в документ ТЦТест
//
// Параметры:
//  Тест  - ДокументСсылка.ТЦТест - ссылка на документ теста
//  НомерИтерации - Число
//  Сценарий - СправочникСсылка.ТЦСценарии
//
Процедура ДобавитьСтруктуруИтерацииВТест(Тест, НомерИтерации, ФактическаяСтруктура)

	Если Тест = Неопределено Тогда
		Возврат
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
		Блокировки = Новый БлокировкаДанных;
		Блокировка = Блокировки.Добавить("Документ.ТЦТест");
		Блокировка.УстановитьЗначение("Ссылка", Тест);
		Блокировки.Заблокировать();
	КонецЕсли;
	
	ТестОбъект = Тест.ПолучитьОбъект();
	
	ТестОбъект.ТекущаяИтерация = НомерИтерации;
	
	Для Каждого СтрокаИтерации Из ФактическаяСтруктура Цикл
		НоваяСтрока = ТестОбъект.СтруктураИтераций.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИтерации);
		НоваяСтрока.НомерИтерации = НомерИтерации;
	КонецЦикла;
	
	ТестОбъект.ОбменДанными.Загрузка = Истина;
	ТестОбъект.Записать();
	
	ЗафиксироватьТранзакцию();

КонецПроцедуры // ДобавитьСтруктуруИтерацииВТест()

// Возвращает структуру ошибки
//
// Параметры:
//    ТекстОшибки - Строка
//	  ВесОшибки - Число
//	  Критическая - Булево
//
// Возвращаемое значение:
//    Структура:
//      ТекстОшибки - Строка
// 	    ВесОшибки - Число
//	    Критическая - Булево
//
Функция ПолучитьСтруктуруОшибки(ТекстОшибки, ВесОшибки, Критическая)
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("ТекстОшибки", ТекстОшибки);
	Ошибка.Вставить("ВесОшибки", ВесОшибки);
	Ошибка.Вставить("Критическая", Критическая);
	
	Возврат Ошибка;
	
КонецФункции

// Записывает ошибку в регистр ТЦОшибки
//
// Параметры:
//  БуферОшибок - ТаблицаЗначений
//  Тест  - ДокументСсылка.ТЦТест - ссылка на документ теста
//  НомерИтерации - Число
//  Ошибка - Структура
//    ТекстОшибки - Строка
//	  ВесОшибки - Число
//	  Критическая - Булево
//
Процедура ЗаписатьОшибку(БуферОшибок, Тест, НомерИтерации, Ошибка)
	
	Если Тест = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(БуферОшибок) <> Тип("ТаблицаЗначений") Тогда
		БуферОшибок	= Новый ТаблицаЗначений;
		БуферОшибок.Колонки.Добавить("Дата", Новый ОписаниеТипов("Дата",,,,,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
		БуферОшибок.Колонки.Добавить("НомерИтерации", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(6,0,ДопустимыйЗнак.Неотрицательный)));
		БуферОшибок.Колонки.Добавить("Ошибка", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0,ДопустимаяДлина.Переменная)));
		БуферОшибок.Колонки.Добавить("ВесОшибки", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0,ДопустимыйЗнак.Неотрицательный)));
	КонецЕсли;
	
	НоваяОшибка = БуферОшибок.Добавить();
	НоваяОшибка.Дата = ТекущаяДата();
	НоваяОшибка.НомерИтерации = НомерИтерации;
	НоваяОшибка.Ошибка = Ошибка.ТекстОшибки;
	НоваяОшибка.ВесОшибки = Ошибка.ВесОшибки;
	
	Запись = РегистрыСведений.ТЦОшибки.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(Запись, НоваяОшибка);
	Запись.Номер = БуферОшибок.Количество();
	Запись.Тест = Тест;
	Запись.Записать();
	
КонецПроцедуры // ЗаписатьОшибку()

// Записывает ошибку в регистр ТЦОшибки и определяет, нужно ли прервать тест
//
// Параметры:
//  БуферОшибок - ТаблицаЗначений
//  Тест - ДокументСсылка.ТЦТест - ссылка на документ теста
//  Агенты - Массив
//  НомерИтерации - Число
//  ТекущееКоличествоОшибок - Число
//  Ошибка - Структура
//
Процедура ОбработатьОшибку(БуферОшибок, Тест, Агенты, НомерИтерации, ТекущееКоличествоОшибок, Ошибка)

	ТекущееКоличествоОшибок = ТекущееКоличествоОшибок + Ошибка.ВесОшибки;
	КритическоеКоличествоОшибокИтерации = Тест.КритическоеКоличествоОшибокИтерации;
	КритическоеКоличествоОшибокТеста = Тест.КритическоеКоличествоОшибокТеста;
	ОбщееКоличествоОшибок = БуферОшибок.Итог("ВесОшибки") + Ошибка.ВесОшибки;
	
	Если Ошибка.Критическая
		ИЛИ (КритическоеКоличествоОшибокИтерации > 0) И (ТекущееКоличествоОшибок >= КритическоеКоличествоОшибокИтерации)
		ИЛИ (КритическоеКоличествоОшибокТеста > 0) И (ОбщееКоличествоОшибок >= КритическоеКоличествоОшибокТеста) Тогда
		
		Если Агенты <> Неопределено Тогда
			ОтправитьСообщенияГруппе(Агенты,, Перечисления.ТЦСообщение.Отменить);
		КонецЕсли;
		
		ТекстИсключения = Ошибка.ТекстОшибки;
		Если Ошибка.Критическая Тогда
			ТекстИсключения = "Произошла критическая ошибка: " + Символы.ПС + Ошибка.ТекстОшибки;
		КонецЕсли;
		
		Если ТекущееКоличествоОшибок = КритическоеКоличествоОшибокИтерации И КритическоеКоличествоОшибокИтерации > 0 Тогда
			
			ТекстИсключения = "На итерации №" + НомерИтерации + " количество ошибок (" + ТекущееКоличествоОшибок + ") достигло критического значения."
			 			  + Символы.ПС + "Общее количество ошибок на всех итерациях: " + ОбщееКоличествоОшибок
						  + Символы.ПС + "Последняя ошибка:" + Символы.ПС + ТекстИсключения;
						  
		ИначеЕсли ТекущееКоличествоОшибок > КритическоеКоличествоОшибокИтерации И КритическоеКоличествоОшибокИтерации > 0 Тогда
						  
			ТекстИсключения = "На итерации №" + НомерИтерации + " количество ошибок (" + ТекущееКоличествоОшибок + ") превысило критическое значение (" + КритическоеКоличествоОшибокИтерации + "). "
			 			  + Символы.ПС + "Общее количество ошибок на всех итерациях: " + ОбщееКоличествоОшибок
						  + Символы.ПС + "Последняя ошибка:" + Символы.ПС + ТекстИсключения;
						  
		ИначеЕсли ОбщееКоличествоОшибок = КритическоеКоличествоОшибокТеста И КритическоеКоличествоОшибокТеста > 0 Тогда
			
			ТекстИсключения = "На итерации №" + НомерИтерации + " общее количество ошибок теста (" + ОбщееКоличествоОшибок + ") достигло критического значения."
						  + Символы.ПС + "Последняя ошибка:" + Символы.ПС + ТекстИсключения;
						  
		ИначеЕсли ОбщееКоличествоОшибок > КритическоеКоличествоОшибокТеста И КритическоеКоличествоОшибокТеста > 0 Тогда
						  
			ТекстИсключения = "На итерации №" + НомерИтерации + " общее количество ошибок теста (" + ОбщееКоличествоОшибок + ") превысило критическое значение (" + КритическоеКоличествоОшибокТеста + "). "
						  + Символы.ПС + "Последняя ошибка:" + Символы.ПС + ТекстИсключения;
		КонецЕсли;
		
		Если БуферОшибок.Количество() > 0 Тогда
			Ошибка.ТекстОшибки = ТекстИсключения;
		КонецЕсли;
		
		ЗаписатьОшибку(БуферОшибок, Тест, НомерИтерации, Ошибка);
		ВызватьИсключение ТекстИсключения;
	Иначе
		ЗаписатьОшибку(БуферОшибок, Тест, НомерИтерации, Ошибка);
	КонецЕсли;
					
КонецПроцедуры // ОбработатьОшибку()

// Добавляет данные о производительности текущей итерации в документ ТЦТест
//
// Параметры:
//  Тест  - ДокументСсылка.ТЦТест - ссылка на документ теста
//  НомерИтерации - Число - номер итерации теста
//  НачалоТекущегоСостоянияВыполнения - Дата 
//  ОкончаниеТекущегоСостоянияВыполнения - Дата
//  ПороговыйAPDEX - Число
//	ТекущаяПроизводительность - Число
//  ТекущееКоличествоКО - Число - текущее количество ключевых операций
//
Процедура ДобавитьПроизводительностьИтерацииВТест(Тест, НомерТекущейИтерации, НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ТекущаяПроизводительность, ТекущееКоличествоКО);

	Если Тест = Неопределено Тогда
		Возврат
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
			Блокировки = Новый БлокировкаДанных;
			Блокировка = Блокировки.Добавить("Документ.ТЦТест");
			Блокировка.УстановитьЗначение("Ссылка", Тест);
			Блокировки.Заблокировать();
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		               |	ЕСТЬNULL(СУММА(ТЦТестСтруктураИтераций.Количество), 0) КАК КоличествоВРМ
		               |ИЗ
		               |	Документ.ТЦТест.СтруктураИтераций КАК ТЦТестСтруктураИтераций
		               |ГДЕ
		               |	ТЦТестСтруктураИтераций.НомерИтерации = &НомерИтерации
		               |	И ТЦТестСтруктураИтераций.Ссылка = &Ссылка
		               |
		               |ДЛЯ ИЗМЕНЕНИЯ
		               |	Документ.ТЦТест";
					   
		Запрос.УстановитьПараметр("НомерИтерации", НомерТекущейИтерации);
		Запрос.УстановитьПараметр("Ссылка", Тест);
		
		Выборка = Запрос.Выполнить().Выбрать();
		Выборка.Следующий();
		КоличествоВРМ = Выборка.КоличествоВРМ;
		
		ТестОбъект = Тест.ПолучитьОбъект();
		
		НоваяСтрока = ТестОбъект.ПроизводительностьИтераций.Добавить();
		НоваяСтрока.НомерИтерации = НомерТекущейИтерации;
		НоваяСтрока.ДатаНачалаИтерации = НачалоТекущегоСостоянияВыполнения;
		НоваяСтрока.ДатаОкончанияИтерации = ОкончаниеТекущегоСостоянияВыполнения;
		НоваяСтрока.Длительность = ОкончаниеТекущегоСостоянияВыполнения - НачалоТекущегоСостоянияВыполнения;
		НоваяСтрока.КоличествоОпераций = ТекущееКоличествоКО;
		НоваяСтрока.КоличествоВРМ = КоличествоВРМ;
		НоваяСтрока.APDEX = ТекущаяПроизводительность;
		
		ТестОбъект.ОбменДанными.Загрузка = Истина;
		ТестОбъект.Записать();
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
		
	
КонецПроцедуры

// Установить менеджер теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест
//
Процедура УстановитьМенеджерТеста(Тест, Менеджер)
	
	Тест.Менеджер = Менеджер;
	
КонецПроцедуры // УстановитьМенеджерТеста()

// Зафиксировать ошибку при выполнении теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//  ИнформацияОбОшибке - ИнформацияОбОшибке
//
Процедура ТестВыполненСОшибкой(Тест, ИнформацияОбОшибке)
	
	ОписаниеОшибки = ТЦОбщий.ИнформациюОбОшибкеВСтруктуру(ИнформацияОбОшибке);
	
	Тест.ИнформацияОбОшибке = Новый ХранилищеЗначения(ОписаниеОшибки);
	Тест.Результат = Перечисления.ТЦРезультатВыполнения.Ошибка;
	Тест.ДатаОкончания = ТекущаяДата();
	
КонецПроцедуры // ТестВыполненСОшибкой()

// Зафиксировать успешное выполнение теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//
Процедура ТестВыполненУспешно(Тест)
	
	Тест.Результат = Перечисления.ТЦРезультатВыполнения.Успешно;
	Тест.ДатаОкончания = ТекущаяДата();
	
КонецПроцедуры // ТестВыполненУспешно()

// Установить новое состояние теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//  Состояние - ПеречислениеСсылка.ТЦСостояние
//
Процедура УстановитьСостояниеТеста(Тест, Состояние)
	
	Если Тест.Состояние <> Состояние Тогда
		Тест.Состояние = Состояние;
		Тест.НачалоСостояния = ТекущаяДата();
	КонецЕсли;
	
КонецПроцедуры // УстановитьСостояниеТеста()

// Установить состояние теста повторно
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//  Состояние - ПеречислениеСсылка.ТЦСостояние
//
Процедура УстановитьСостояниеТестаПовторно(Тест, Состояние)
	
	Тест.Состояние = Состояние;
	Тест.НачалоСостояния = ТекущаяДата();
	
КонецПроцедуры // УстановитьСостояниеТеста()

// Установить состояние запуска ВРМ
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//  ВРМЗапущены - Булево
//
Процедура УстановитьСостояниеЗапускаВРМ(Тест, ВРМЗапущены)
	
	Тест.ВРМЗапущены = ВРМЗапущены;
	
КонецПроцедуры // УстановитьСостояниеЗапускаВРМ()

// Установить или снять паузу после запуска ВРМ
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест, тест, при выполнеии которого произошла ошибка
//  Пауза - Булево
//
Процедура УстановитьПаузуПослеЗапускаВРМ(Тест, Пауза)
	
	Тест.ПаузаПослеЗапускаВРМ = Пауза;
	
КонецПроцедуры // УстановитьПаузуПослеЗапускаВРМ()

// Прервать выполнение теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест
//
Процедура ПрерватьТест(Тест)
	
	УстановитьРезультатТеста(Перечисления.ТЦРезультатВыполнения.Неопределено);
	Тест.Прерван = Истина;
	Тест.ДатаОкончания = ТекущаяДата();
	
КонецПроцедуры // ПрерватьТест()

// Завершить выполнение теста
//
// Параметры:
//  Тест - ДокументОбъект.ТЦТест
//
Процедура ЗавершитьТест(Тест)
	
	Тест.Завершен = Истина;
	
КонецПроцедуры // ЗавершитьТест()

// Получить ссылку на текущий тест
//
// Возвращаемое значение:
//  ДокументСсылка.ТЦТест - ссылка на выполняемый в данный момент тест
//  Неопределено, если в данный момент времени тесты не выполняются
//
Функция ТекущийТест() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТЦТест.Ссылка
				   |ИЗ
	               |	Документ.ТЦТест КАК ТЦТест
	               |ГДЕ
	               |	ТЦТест.Результат = ЗНАЧЕНИЕ(Перечисление.ТЦРезультатВыполнения.Неопределено)
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТЦТест.Дата УБЫВ";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 
	
КонецФункции // ТекущийТест()

// Получить ссылку на текущий тест и наименование сценария этого теста
//
// Возвращаемое значение:
//  Структура:
//		Тест		- ДокументСсылка.ТЦТест - ссылка на выполняемый в данный момент тест
//		Сценарий	- Строка - наименования сценария выполняющегося в данный момент теста
//
//  Неопределено, если в данный момент времени тесты не выполняются
//
Функция ТекущийТестИСценарий() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТЦТест.Ссылка,
	               |	ТЦТест.Сценарий
	               |ИЗ
	               |	Документ.ТЦТест КАК ТЦТест
	               |ГДЕ
	               |	ТЦТест.Результат = ЗНАЧЕНИЕ(Перечисление.ТЦРезультатВыполнения.Неопределено)
	               |	И ТЦТест.Прерван = ЛОЖЬ
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТЦТест.Дата УБЫВ";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		ТестИСценарий = Новый Структура;
		ТестИСценарий.Вставить("Тест", Выборка.Ссылка);
		ТестИСценарий.Вставить("Сценарий", Выборка.Сценарий);
		Возврат ТестИСценарий;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 
	
КонецФункции // ТекущийТестИСценарий()

// Получить ссылку на последний тест и наименование сценария этого теста
//
// Возвращаемое значение:
//  Структура:
//		Тест		- ДокументСсылка.ТЦТест - ссылка на выполняемый в данный момент тест
//		Сценарий	- Строка - наименования сценария выполняющегося в данный момент теста
//
//  Неопределено, если в данный момент времени тесты не выполняются
//
Функция ПоследнийТестИСценарий() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТЦТест.Ссылка,
	               |	ТЦТест.Сценарий
	               |ИЗ
	               |	Документ.ТЦТест КАК ТЦТест
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТЦТест.Дата УБЫВ";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		ТестИСценарий = Новый Структура;
		ТестИСценарий.Вставить("Тест", Выборка.Ссылка);
		ТестИСценарий.Вставить("Сценарий", Выборка.Сценарий);
		Возврат ТестИСценарий;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 
	
КонецФункции // ТекущийТестИСценарий()

// Проверить, завершен ли тест
//
// Параметры:
//  Тест
//
// Возвращаемое значение:
//  Структура:
//		НачалоСостояния		- Дата - дата начала указанного состояния теста
//		ИнформацияОбОшибке	- Строка - информация о текущей ошибке
//		Прерван				- Булево - признак того, что тест прерван
//		Завершен			- Булево - признак завершения теста
//		Результат			- ПеречислениеСсылка.ТЦРезультатВыполнения - результат выполнения теста
//		Состояние			- ПеречислениеСсылка.ТЦСостояние - текущее состояние теста
//		ТаймаутВыполнения	- Число - таймаут выполнения
//		ТаймаутЗаписиРезультатов- Число - таймаут записи результатов
//		ТаймаутИнициализации	- Число - таймаут инициализации
//		ТаймаутПодготовки		- Число - таймаут подготовки
//		ТаймаутУдаленияДанных  	- Число - таймаут удаления данных
//		ПаузаПослеЗапускаВРМ	- Булево - указание сделать паузу после запуска ВРМ
//		ВРМЗапущены				- Булево - признак того, что ВРМ запущены
//		ДатаНачала				- Дата - дата начала тестирования
//		ДатаОкончания			- Дата - дата окончания тестирования
//
Функция СостояниеТеста(Тест) Экспорт
	
	НачатьТранзакцию();
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Тест);
	Запрос.Текст = "ВЫБРАТЬ
	               |	СУММА(ТЦОшибки.ВесОшибки) КАК ОбщееКоличествоОшибок
	               |ПОМЕСТИТЬ ВремОбщееКоличествоОшибок
	               |ИЗ
	               |	РегистрСведений.ТЦОшибки КАК ТЦОшибки
	               |ГДЕ
	               |	ТЦОшибки.Тест = &Ссылка
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ТЦТест.НачалоСостояния,
	               |	ТЦТест.ИнформацияОбОшибке,
	               |	ТЦТест.Прерван,
	               |	ТЦТест.Завершен,
	               |	ТЦТест.Результат,
	               |	ТЦТест.Состояние,
	               |	ТЦТест.ТаймаутВыполнения,
	               |	ТЦТест.ТаймаутЗаписиРезультатов,
	               |	ТЦТест.ТаймаутИнициализации,
	               |	ТЦТест.ТаймаутПодготовки,
	               |	ТЦТест.ТаймаутУдаленияДанных,
	               |	ТЦТест.ПаузаПослеЗапускаВРМ,
	               |	ТЦТест.ВРМЗапущены,
	               |	ТЦТест.Дата КАК ДатаНачала,
	               |	ТЦТест.ДатаОкончания КАК ДатаОкончания,
	               |	ТЦТест.ТекущаяИтерация,
	               |	ТЦТест.МаксимальноеКоличествоИтераций,
	               |	ТЦТест.ЭтоДинамическийТест,
	               |	ТЦТест.КритическоеКоличествоОшибокТеста,
	               |	ТЦТест.КритическоеКоличествоОшибокИтерации,
	               |	ТЦТест.Менеджер
	               |ПОМЕСТИТЬ ОсновныеДанные
	               |ИЗ
	               |	Документ.ТЦТест КАК ТЦТест
	               |ГДЕ
	               |	ТЦТест.Ссылка = &Ссылка
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	СУММА(ТЦОшибки.ВесОшибки) КАК ТекущееКоличествоОшибок
	               |ПОМЕСТИТЬ ВремТекущееКоличестоОшибок
	               |ИЗ
	               |	РегистрСведений.ТЦОшибки КАК ТЦОшибки
	               |ГДЕ
	               |	ТЦОшибки.Тест = &Ссылка
	               |	И ТЦОшибки.НомерИтерации В
	               |			(ВЫБРАТЬ ПЕРВЫЕ 1
	               |				ОсновныеДанные.ТекущаяИтерация
	               |			ИЗ
	               |				ОсновныеДанные КАК ОсновныеДанные)
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ОсновныеДанные.НачалоСостояния,
	               |	ОсновныеДанные.ИнформацияОбОшибке,
	               |	ОсновныеДанные.Прерван,
	               |	ОсновныеДанные.Завершен,
	               |	ОсновныеДанные.Результат,
	               |	ОсновныеДанные.Состояние,
	               |	ОсновныеДанные.ТаймаутВыполнения,
	               |	ОсновныеДанные.ТаймаутЗаписиРезультатов,
	               |	ОсновныеДанные.ТаймаутИнициализации,
	               |	ОсновныеДанные.ТаймаутПодготовки,
	               |	ОсновныеДанные.ТаймаутУдаленияДанных,
	               |	ОсновныеДанные.ПаузаПослеЗапускаВРМ,
	               |	ОсновныеДанные.ВРМЗапущены,
	               |	ОсновныеДанные.ДатаНачала,
	               |	ОсновныеДанные.ДатаОкончания,
	               |	ОсновныеДанные.ТекущаяИтерация,
	               |	ОсновныеДанные.МаксимальноеКоличествоИтераций,
	               |	ОсновныеДанные.ЭтоДинамическийТест,
	               |	ОсновныеДанные.КритическоеКоличествоОшибокТеста,
	               |	ОсновныеДанные.КритическоеКоличествоОшибокИтерации,
	               |	ОсновныеДанные.Менеджер,
	               |	ЕСТЬNULL(ВремТекущееКоличестоОшибок.ТекущееКоличествоОшибок, 0) КАК ТекущееКоличествоОшибок,
	               |	ЕСТЬNULL(ВремОбщееКоличествоОшибок.ОбщееКоличествоОшибок, 0) КАК ОбщееКоличествоОшибок
	               |ИЗ
	               |	ОсновныеДанные КАК ОсновныеДанные,
	               |	ВремТекущееКоличестоОшибок КАК ВремТекущееКоличестоОшибок,
	               |	ВремОбщееКоличествоОшибок КАК ВремОбщееКоличествоОшибок";
				   
	Выборка = Запрос.Выполнить().Выбрать();
	ЗафиксироватьТранзакцию();
	
	Если Выборка.Следующий() Тогда
		
		Результат = Новый Структура;
		Результат.Вставить("НачалоСостояния", Выборка.НачалоСостояния);
		Результат.Вставить("ИнформацияОбОшибке", Выборка.ИнформацияОбОшибке.Получить());
		Результат.Вставить("Прерван", Выборка.Прерван);
		Результат.Вставить("Завершен", Выборка.Завершен);
		Результат.Вставить("Результат", Выборка.Результат);
		Результат.Вставить("Состояние", Выборка.Состояние);
		Результат.Вставить("ТаймаутВыполнения", Выборка.ТаймаутВыполнения);
		Результат.Вставить("ТаймаутЗаписиРезультатов", Выборка.ТаймаутЗаписиРезультатов);
		Результат.Вставить("ТаймаутИнициализации", Выборка.ТаймаутИнициализации);
		Результат.Вставить("ТаймаутПодготовки", Выборка.ТаймаутПодготовки);
		Результат.Вставить("ТаймаутУдаленияДанных", Выборка.ТаймаутУдаленияДанных);
		Результат.Вставить("ПаузаПослеЗапускаВРМ", Выборка.ПаузаПослеЗапускаВРМ);
		Результат.Вставить("ВРМЗапущены", Выборка.ВРМЗапущены);
		Результат.Вставить("ДатаНачала", Выборка.ДатаНачала);
		Результат.Вставить("ДатаОкончания", Выборка.ДатаОкончания);
		Результат.Вставить("ТекущаяИтерация", Выборка.ТекущаяИтерация);
		Результат.Вставить("МаксимальноеКоличествоИтераций", Выборка.МаксимальноеКоличествоИтераций);
		Результат.Вставить("ЭтоДинамическийТест", Выборка.ЭтоДинамическийТест);
		Результат.Вставить("КритическоеКоличествоОшибокИтерации", Выборка.КритическоеКоличествоОшибокИтерации);
		Результат.Вставить("КритическоеКоличествоОшибокТеста", Выборка.КритическоеКоличествоОшибокТеста);
		Результат.Вставить("ТекущееКоличествоОшибок", Выборка.ТекущееКоличествоОшибок);
		Результат.Вставить("ОбщееКоличествоОшибок", Выборка.ОбщееКоличествоОшибок);
		
		Если Выборка.Результат = Перечисления.ТЦРезультатВыполнения.Неопределено
			ИЛИ  Выборка.Результат = Перечисления.ТЦРезультатВыполнения.ПустаяСсылка() Тогда
			
			Диагностика = ДиагностироватьИЗавершитьТестСОшибкойФЗ(Тест, Выборка.Менеджер);
			Если Диагностика <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(Результат, Диагностика, "Результат,ИнформацияОбОшибке,ДатаОкончания");
			КонецЕсли;

		КонецЕсли;
		
		Возврат Результат;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 
	
КонецФункции // СостояниеТеста()

// Отмечает, что тест завершился с ошибкой в случае, если фоновое задание теста завершается с ошибкой.
//
// Параметры:
//  Тест  - ДокументСсылка.ТЦТест - ссылка на документ теста
//
//  ИдЗадания - Строка - идентификатор фонового задания теста, обычно хранится в реквизите документа ТЦТест.Менеджер
//
Функция ДиагностироватьИЗавершитьТестСОшибкойФЗ(Тест, ИдЗадания = Неопределено) Экспорт

	Диагностика = Неопределено;
	
	Если ИдЗадания = Неопределено Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		               |	ТЦТест.Менеджер КАК Менеджер
		               |ИЗ
		               |	Документ.ТЦТест КАК ТЦТест
		               |ГДЕ
		               |	ТЦТест.Ссылка = &Тест";
		
		Запрос.УстановитьПараметр("Тест", Тест);
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда  // Это невозможная ситуация при штатной работе Тест-центра.
			
			Попытка
				
				НачатьТранзакцию();
				
				Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
					Блокировки = Новый БлокировкаДанных;
					Блокировка = Блокировки.Добавить("Документ.ТЦТест");
					Блокировка.УстановитьЗначение("Ссылка", Тест);
					Блокировки.Заблокировать();
				КонецЕсли;
				
				ТестОбъект = Тест.ПолучитьОбъект();
				Если ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.Неопределено
					ИЛИ  ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.ПустаяСсылка() Тогда
						
					Попытка
						ВызватьИсключение "Не удалось определить идентификатор фонового задания теста " + СокрЛП(Тест);
					Исключение
						Ошибка = ИнформацияОбОшибке();
					КонецПопытки;
					
					ОписаниеОшибки = ТЦОбщий.ИнформациюОбОшибкеВСтруктуру(Ошибка);
					
					ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.Ошибка;
					ТестОбъект.ИнформацияОбОшибке = Новый ХранилищеЗначения(ОписаниеОшибки);
					ТестОбъект.ДатаОкончания = ТекущаяДата();
					ТестОбъект.Записать();
					
					Диагностика = Новый Структура;
					Диагностика.Вставить("Результат", ТестОбъект.Результат);
					Диагностика.Вставить("ИнформацияОбОшибке", ОписаниеОшибки);
					Диагностика.Вставить("ДатаОкончания", ТестОбъект.ДатаОкончания);
					
					ОтправитьОтменуАгентам();
					
				КонецЕсли;
					
				ЗафиксироватьТранзакцию();
				
			Исключение
				ТЦОбщий.ЗаписатьВЖурнал(ИнформацияОбОшибке(), "Тест-центр");
			КонецПопытки;
			
			Возврат Диагностика;
			
		КонецЕсли;
		
		Выборка = РезультатЗапроса.Выбрать();
		ИдЗадания = Выборка.Менеджер;

	КонецЕсли;
	
	ФоновоеЗаданиеТеста = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(ИдЗадания));
	СостояниеЗаданияТеста = Неопределено;
	Если ФоновоеЗаданиеТеста <> Неопределено Тогда
		СостояниеЗаданияТеста = ФоновоеЗаданиеТеста.Состояние;
	КонецЕсли;
	
	Если СостояниеЗаданияТеста = СостояниеФоновогоЗадания.Активно Тогда
		Возврат Диагностика
	КонецЕсли;
	
	
	Попытка
		НачатьТранзакцию();
		
		Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
			Блокировки = Новый БлокировкаДанных;
			Блокировка = Блокировки.Добавить("Документ.ТЦТест");
			Блокировка.УстановитьЗначение("Ссылка", Тест);
			Блокировки.Заблокировать();
		КонецЕсли;
		
		ТестОбъект = Тест.ПолучитьОбъект();
		
		Если ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.Неопределено
			ИЛИ  ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.ПустаяСсылка() Тогда
			
			ТестОбъект.Результат = Перечисления.ТЦРезультатВыполнения.Ошибка;
			
			Попытка
				
				Если СостояниеЗаданияТеста = СостояниеФоновогоЗадания.Завершено Тогда
					ВызватьИсключение "Обнаружено, что фоновое задание теста было завершено без определения результата теста.";
					
				ИначеЕсли СостояниеЗаданияТеста = СостояниеФоновогоЗадания.Отменено Тогда
					ВызватьИсключение "Обнаружено, что фоновое задание теста было отменено.";
					
				ИначеЕсли СостояниеЗаданияТеста = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
					ВызватьИсключение "Обнаружено, что фоновое задание теста было завершено аварийно без определения результата теста.";
					
				ИначеЕсли СостояниеЗаданияТеста = Неопределено Тогда
					ВызватьИсключение "Фоновое задание теста не найдено.";
					
				КонецЕсли;
				
			Исключение
				
				ОписаниеОшибки = ТЦОбщий.ИнформациюОбОшибкеВСтруктуру(ИнформацияОбОшибке());
				ТестОбъект.ИнформацияОбОшибке = Новый ХранилищеЗначения(ОписаниеОшибки);
				ТестОбъект.ДатаОкончания = ТекущаяДата();
				ТестОбъект.Записать();
				
				Диагностика = Новый Структура;
				Диагностика.Вставить("Результат", ТестОбъект.Результат);
				Диагностика.Вставить("ИнформацияОбОшибке", ОписаниеОшибки);
				Диагностика.Вставить("ДатаОкончания", ТестОбъект.ДатаОкончания);
				
				ОтправитьОтменуАгентам();
				
			КонецПопытки;
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ТЦОбщий.ЗаписатьВЖурнал(ИнформацияОбОшибке(), "Тест-центр");
	КонецПопытки;
	
	Возврат Диагностика;

КонецФункции // ДиагностироватьИЗавершитьТестСОшибкойФЗ()

// Отправить команду отмены выполнения теста для Агентов
//
Процедура ОтправитьОтменуАгентам() Экспорт

	ЗапросАгентов = Новый Запрос;
	ЗапросАгентов.Текст = "ВЫБРАТЬ
	               |	ТЦАгенты.Ссылка
	               |ИЗ
	               |	Справочник.ТЦАгенты КАК ТЦАгенты";
				   
	РезультатЗапросаАгентов = ЗапросАгентов.Выполнить();
	Если Не РезультатЗапросаАгентов.Пустой() Тогда
		Агенты = РезультатЗапросаАгентов.Выгрузить().ВыгрузитьКолонку("Ссылка");
		ОтправитьСообщенияГруппе(Агенты, , Перечисления.ТЦСообщение.Отменить);
	КонецЕсли;

КонецПроцедуры // ОтправитьОтменуАгентам()

// Получает количество запущенных и незапущенных пользователей
//
// Возвращаемое значение:
//   Структура   - "ПользователейЗапущено" - Число
//               - "ПользователейОсталосьЗапустить" - Число
Функция ПолучитьКоличествоЗапущенныхИНезапущенных() Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЕСТЬNULL(СУММА(ВЫБОР
	               |				КОГДА ТЦСценарийЗапуска.Запущен = 2
	               |					ТОГДА 1
	               |				ИНАЧЕ 0
	               |			КОНЕЦ), 0) КАК ВРМЗапущено,
	               |	КОЛИЧЕСТВО(*) КАК ВРМВсего
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска";
				   
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Результат.Вставить("ВРМЗапущено", Выборка.ВРМЗапущено);
	Результат.Вставить("ВРМОсталосьЗапустить", Выборка.ВРМВсего - Выборка.ВРМЗапущено);
	
	Возврат Результат;

КонецФункции // ПолучитьКоличествоЗапущенныхИНезапущенных()


///////////////////////////////////////////////////////////////////////////////
// УПРАВЛЕНИЕ ПРОЦЕССОМ ТЕСТИРОВАНИЯ

// Выпонить указанный сценарий
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий
//
// Возвращаемое значение:
//  ДокументСсылка.ТЦТест - ссылка тест по выбранному сценарию, либо Документы.ТЦТест.ПустаяСсылка(), если в данный момент тест выполняется
//
Функция ВыполнитьСценарий(Сценарий, ПараметрыВыполнения = Неопределено) Экспорт
	
	ТЦОбщий.СформироватьИЛИДополнитьПараметрыВыполнения(ПараметрыВыполнения);
	
	НачатьТранзакцию();
	
	Попытка
		
		// Установим сценарий в справочнике управления тестом
		Попытка
			ЗаписьУправленияТестом = ПолучитьЗаписьУправленияТестомПоИдентификатору();
			Если ЗначениеЗаполнено(ЗаписьУправленияТестом) Тогда
				ОбъектЗаписи = ЗаписьУправленияТестом.ПолучитьОбъект();
				ОбъектЗаписи.Сценарий = Сценарий;
				ОбъектЗаписи.ОбменДанными.Загрузка = Истина;
				ОбъектЗаписи.Записать();
			КонецЕсли;
		Исключение
			ТЦОбщий.ЗаписатьВЖурнал(ИнформацияОбОшибке());
		КонецПопытки;
		
		Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Документ.ТЦТест");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.ТЦСценарийЗапуска");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			Блокировка.Заблокировать();
		КонецЕсли;
		
		Если ТестВыполняется() Тогда
			УстановитьРезультатТеста(Перечисления.ТЦРезультатВыполнения.Ошибка);
			ЗафиксироватьТранзакцию();
			Возврат Документы.ТЦТест.ПустаяСсылка();			
		КонецЕсли;
		
		Тест = СоздатьТест(Сценарий, ПараметрыВыполнения);
		
		// Очистим сценарий запуска
		СценарийЗапуска = РегистрыСведений.ТЦСценарийЗапуска.СоздатьНаборЗаписей();
		СценарийЗапуска.ОбменДанными.Загрузка = Истина;
		СценарийЗапуска.Записать();
		
		Параметры = Новый Массив;
		Параметры.Добавить(Сценарий);
		Параметры.Добавить(Тест);
		Параметры.Добавить(ПараметрыВыполнения);
				
		ИмяЗадания = "ТЦСервер.ЗаданиеВыполнитьСценарий";
		Задание = ФоновыеЗадания.Выполнить(ИмяЗадания, Параметры);
		ИзменитьТест(Тест, "УстановитьМенеджерТеста", Задание.УникальныйИдентификатор);
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат Тест.Ссылка;
	
КонецФункции // ВыполнитьСценарий()

// Прервать выполнение теста
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ПрерватьВыполнениеТеста(Тест) Экспорт
	
	ИзменитьТест(Тест, "ПрерватьТест");
	
КонецПроцедуры // ПрерватьВыполнениеСценария()

// Завершить выполнение теста
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ЗавершитьВыполнениеТеста(Тест) Экспорт
	
	ИзменитьТест(Тест, "ЗавершитьТест");
	
КонецПроцедуры // ЗавершитьВыполнениеТеста()

// Обработчик фонового задания, выполненяющего сценарий
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ЗаданиеВыполнитьСценарий(Сценарий,
									Тест,
									ПараметрыВыполнения) Экспорт

	Попытка
		ПриВыполненииСценария(Сценарий, Тест, ПараметрыВыполнения);
		ИзменитьТест(Тест, "ТестВыполненУспешно");
	Исключение
		Ошибка = ИнформацияОбОшибке();
		ТЦОбщий.ЗаписатьВЖурнал(Ошибка, "Тест-центр");
		ИзменитьТест(Тест, "ТестВыполненСОшибкой", Ошибка);
	КонецПопытки;
	
КонецПроцедуры // ЗаданиеВыполнитьСценарий()

// Обработчик выполнения сценария
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ПриВыполненииСценария(Сценарий,
								Тест,
								ПараметрыВыполнения)
								
	НачальноеКоличествоПользователей	= ПараметрыВыполнения.НачальноеКоличествоПользователей;
	РазмерРезерва						= ПараметрыВыполнения.РазмерРезерва;
	НачальныйШагДозапускаПользователей	= ПараметрыВыполнения.НачальныйШагДозапускаПользователей;
	КонечныйШагДозапускаПользователей	= ПараметрыВыполнения.КонечныйШагДозапускаПользователей;
	ПороговыйAPDEX						= ПараметрыВыполнения.ПороговыйAPDEX;
	МаксимальноеКоличествоИтераций		= ПараметрыВыполнения.МаксимальноеКоличествоИтераций;
	ЭтоДинамическийТест					= ПараметрыВыполнения.ЭтоДинамическийТест;
	РаспределятьПоКомпьютерамРавномерно	= ПараметрыВыполнения.РаспределятьПоКомпьютерамРавномерно;
	КоэффициентИнтенсивности			= ПараметрыВыполнения.КоэффициентИнтенсивности;
	АдресПубликации						= ПараметрыВыполнения.АдресПубликации;
	ЕстьРазделение						= ПараметрыВыполнения.ЕстьРазделение;
	ТаблицаРаспределения				= ПараметрыВыполнения.ТаблицаРаспределения;
	
	Если ПараметрыВыполнения.ОбщееКоличествоОдновременноЗапускаемыхВРМ <> Неопределено
		И ПараметрыВыполнения.ОбщееКоличествоОдновременноЗапускаемыхВРМ > 0 Тогда
		ОбщееКоличествоОдновременноЗапускаемыхВРМ = ПараметрыВыполнения.ОбщееКоличествоОдновременноЗапускаемыхВРМ;
	Иначе
		ОбщееКоличествоОдновременноЗапускаемыхВРМ = Сценарий.ОбщееКоличествоОдновременноЗапускаемыхВРМ;
	КонецЕсли;
	
	ПараметрыВыполнения.ОбщееКоличествоОдновременноЗапускаемыхВРМ = ОбщееКоличествоОдновременноЗапускаемыхВРМ;
	
	КоличествоОдновременноЗапускаемыхВРМАгента = 10;
	Если ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента <> Неопределено
		И ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента > 0 Тогда
		
		КоличествоОдновременноЗапускаемыхВРМАгента		= ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента;
	ИначеЕсли Сценарий.КоличествоОдновременноЗапускаемыхВРМАгента > 0 Тогда
		КоличествоОдновременноЗапускаемыхВРМАгента		= Сценарий.КоличествоОдновременноЗапускаемыхВРМАгента;
	КонецЕсли;

	ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента = КоличествоОдновременноЗапускаемыхВРМАгента;
	
	НомерТекущейИтерации				= 0;
	НужныДополнительныеИтерации			= Ложь;
	ТекущаяПроизводительность			= 0;
	ТекущееКоличествоКО					= 0;
	ТекущийШагДозапускаПользователей	= НачальныйШагДозапускаПользователей;
	ТекущееКоличествоПользователей		= ПараметрыВыполнения.НачальноеКоличествоПользователей;
	ИспользоватьТолькоКлонов			= МаксимальноеКоличествоИтераций > 1;
	ОбщееКоличествоОшибок				= 0;
	ТекущееКоличествоОшибок				= 0;
	ТаймаутОпросаАгентов				= 20;
	ПервыйЭтапВыполненияУжеБыл			= Ложь;
	НачалоТекущегоСостоянияВыполнения		= Неопределено;
	ОкончаниеТекущегоСостоянияВыполнения	= Неопределено; 
	ПредыдущийСценарийЗапуска				= Неопределено;
	СценарийПредыдущейИтерации				= Неопределено;
	Агенты 									= Неопределено;
	
	БуферОшибок	= Новый ТаблицаЗначений;
	БуферОшибок.Колонки.Добавить("Дата", Новый ОписаниеТипов("Дата",,,,,Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));
	БуферОшибок.Колонки.Добавить("НомерИтерации", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(6,0,ДопустимыйЗнак.Неотрицательный)));
	БуферОшибок.Колонки.Добавить("Ошибка", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0,ДопустимаяДлина.Переменная)));
	БуферОшибок.Колонки.Добавить("ВесОшибки", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0,ДопустимыйЗнак.Неотрицательный)));
	
	// Сразу настроим пользователей исходя из итерации с наибольшим количеством пользователей
	МаксимальноеКоличествоПользователей = НачальноеКоличествоПользователей + НачальныйШагДозапускаПользователей * (МаксимальноеКоличествоИтераций - 1);
	Если МаксимальноеКоличествоИтераций > 1 Тогда
		СтруктураМаксимальнойИтерации = ПолучитьФактическуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации, МаксимальноеКоличествоПользователей, РазмерРезерва, "", Ложь, Ложь, Неопределено); // Здесь масштабируем только на нужное количество пользователей + резерв ВРМ
	Иначе // для единственной итерации рассчитаем структуру итерации полностью
		СтруктураМаксимальнойИтерации = ПолучитьФактическуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации, ТекущееКоличествоПользователей, РазмерРезерва, АдресПубликации, ЕстьРазделение, РаспределятьПоКомпьютерамРавномерно, ТаблицаРаспределения);
	КонецЕсли;
	
	НастроитьПользователей(СтруктураМаксимальнойИтерации, ИспользоватьТолькоКлонов);
	
	Если ТестПрерван(Тест) Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаВыполнения	= СформироватьТаблицуВыполнения(Сценарий, Тест, ПараметрыВыполнения);
	Инструменты			= КипВнешнийКомпонент.ПолучитьИнструменты();
	
	Для Каждого Задание Из ТаблицаВыполнения Цикл
		
		// Установить новое состояние Теста
		ТекущееСостояние = Задание.Параметры.Состояние;
		Если Задание.ЭтоПовтор Тогда
			ИзменитьТест(Тест, "УстановитьСостояниеТестаПовторно", ТекущееСостояние);
		Иначе
			ИзменитьТест(Тест, "УстановитьСостояниеТеста", ТекущееСостояние);
		КонецЕсли;
		
		// Если текущее задание - подготовка, и номер итерации изменился,
		// следует выполнить подготовительные действия над сценарием
		Если НомерТекущейИтерации <> Задание.НомерИтерации Тогда
			
			НомерТекущейИтерации = Задание.НомерИтерации;
			
			СценарийРассчитан = Ложь;
			ЭтоПовторныйРасчет = Ложь;
			Пока СценарийРассчитан = Ложь Цикл
				
				// Получить фактическую структуру сценария
				Если МаксимальноеКоличествоИтераций > 1 ИЛИ ЭтоПовторныйРасчет Тогда
					ФактическаяСтруктура = ПолучитьФактическуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации, ТекущееКоличествоПользователей, РазмерРезерва, АдресПубликации, ЕстьРазделение, РаспределятьПоКомпьютерамРавномерно, ТаблицаРаспределения);
				Иначе // Если итерация в тесте всего одна, то используем ранее рассчитанную структуру итерации
					ФактическаяСтруктура = СтруктураМаксимальнойИтерации;
				КонецЕсли;
				
				// Зафиксируем структуру текущей итерации в документе теста
				ДобавитьСтруктуруИтерацииВТест(Тест, НомерТекущейИтерации, ФактическаяСтруктура);
				
				ВесаКомпьютеров = ПолучитьВесаКомпьютеров(ФактическаяСтруктура);
				КомпьютерыБезАгентов = КомпьютерыБезАгентов(ФактическаяСтруктура);
				КоличествоКомпьютеровБезАгентов = КомпьютерыБезАгентов.Количество();
				
				Если ТестПрерван(Тест) Тогда
					
					Если НачалоТекущегоСостоянияВыполнения <> Неопределено И ОкончаниеТекущегоСостоянияВыполнения = Неопределено Тогда
						ОкончаниеТекущегоСостоянияВыполнения = ТекущаяУниверсальнаяДата();
						ПолучитьУдовлетворительностьПроизводительности(НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ПороговыйAPDEX, ТекущаяПроизводительность, ТекущееКоличествоКО);
						ДобавитьПроизводительностьИтерацииВТест(Тест, НомерТекущейИтерации, НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ТекущаяПроизводительность, ТекущееКоличествоКО);
					КонецЕсли;
					
					Возврат;
				КонецЕсли;
				
				Если КоличествоКомпьютеровБезАгентов > 0 Тогда
					
					ЭтоКритическаяОшибка = Ложь;
					ВесОшибки = 0;
					
					Список = ТЦОбщий.МассивВСтроку(КомпьютерыБезАгентов, "
						| - ", Истина);
					ТекстОшибки = "Не найдены агенты на следующих компьютерах:" + Список;
											
					Для Каждого ТекущийКомпьютер Из КомпьютерыБезАгентов Цикл
						ВесОшибки = ВесОшибки + ВесаКомпьютеров[ТекущийКомпьютер];
					КонецЦикла;
					
					Если ВесаКомпьютеров.Количество() - КоличествоКомпьютеровБезАгентов = 0 Тогда
						ЭтоКритическаяОшибка = Истина;
						ТекстОшибки = "Критическая ошибка: не найдено ни одного компьютера с запущенным агентом." + Символы.ПС + ТекстОшибки;
					КонецЕсли;
					
					// Записать ошибку и отменить выполнение задания, если дальнейшее выполнение невозможно
					Ошибка = ПолучитьСтруктуруОшибки(ТекстОшибки, ВесОшибки, ЭтоКритическаяОшибка);
					ОбработатьОшибку(БуферОшибок, Тест, Агенты, НомерТекущейИтерации, ТекущееКоличествоОшибок, Ошибка);
					
					Если ТаблицаРаспределения <> Неопределено Тогда
						Сч = ТаблицаРаспределения.Количество() - 1;
						Пока Сч >= 0 Цикл
							ТекущийКомпьютер = ТаблицаРаспределения[Сч].Компьютер;
							Если КомпьютерыБезАгентов.Найти(ТекущийКомпьютер) <> Неопределено Тогда
								ТаблицаРаспределения.Удалить(Сч);
							КонецЕсли;
							Сч = Сч - 1;
						КонецЦикла;
					КонецЕсли;
					
					Если ПредыдущийСценарийЗапуска <> Неопределено Тогда
						Сч = ПредыдущийСценарийЗапуска.Количество() - 1;
						Пока Сч >= 0 Цикл
							ТекущийКомпьютер = ПредыдущийСценарийЗапуска[Сч].Компьютер;
							Если КомпьютерыБезАгентов.Найти(ТекущийКомпьютер) <> Неопределено Тогда
								ПредыдущийСценарийЗапуска.Удалить(Сч);
							КонецЕсли;
							Сч = Сч - 1;
						КонецЦикла;
					КонецЕсли;
					
					// Рассчитаем сценарий с учетом полученных ошибок
					ЭтоПовторныйРасчет = Истина;
					Продолжить;
					
				КонецЕсли;			
				
				ПодготовитьСценарийЗапуска(ФактическаяСтруктура, ИспользоватьТолькоКлонов, ПредыдущийСценарийЗапуска, ЭтоДинамическийТест, ОбщееКоличествоОдновременноЗапускаемыхВРМ);
				Агенты = АгентыСценария(ФактическаяСтруктура);
				ВесаАгентов = ПолучитьВесаАгентов(Агенты);
				
				КоличествоАгентовКомпьютеров = Новый Соответствие;
				Для Каждого ТекущийАгент Из Агенты Цикл
					ТекущееКоличествоАгентов = КоличествоАгентовКомпьютеров[ТекущийАгент.Компьютер];
					Если ТекущееКоличествоАгентов = Неопределено Тогда
						КоличествоАгентовКомпьютеров.Вставить(ТекущийАгент.Компьютер, 1);
					Иначе
						КоличествоАгентовКомпьютеров.Вставить(ТекущийАгент.Компьютер, ТекущееКоличествоАгентов + 1);
					КонецЕсли;
				КонецЦикла;
				
				// Проверим, работают ли необходимые для сценария агенты							
				РезультатПроверки = ПроверитьАктивностьАгентов(Агенты, Тест, ТаймаутОпросаАгентов);
				Если ТестПрерван(Тест) Тогда
					
					Если НачалоТекущегоСостоянияВыполнения <> Неопределено И ОкончаниеТекущегоСостоянияВыполнения = Неопределено Тогда
						ОкончаниеТекущегоСостоянияВыполнения = ТекущаяУниверсальнаяДата();
						ПолучитьУдовлетворительностьПроизводительности(НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ПороговыйAPDEX, ТекущаяПроизводительность, ТекущееКоличествоКО);
						ДобавитьПроизводительностьИтерацииВТест(Тест, НомерТекущейИтерации, НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ТекущаяПроизводительность, ТекущееКоличествоКО);
					КонецЕсли;
					
					Возврат;
				КонецЕсли;
				
				Если РезультатПроверки.КоличествоНеактивных > 0 Тогда
					
					Неотвечающие = РезультатПроверки.Неполучившие;
					ЭтоКритическаяОшибка = Ложь;
					ВесОшибки = 0;
					
					Если Неотвечающие.Количество() > 0 Тогда
						Список = ТЦОбщий.МассивВСтроку(РезультатПроверки.Неполучившие, "
							| - ", Истина);
						ТекстОшибки = "Следующие агенты не отвечают (возможно, не запущены):" + Список;
						
						Для Каждого ТекущийНеответивший Из Неотвечающие Цикл
							ВесОшибки = ВесОшибки + ВесаАгентов[ТекущийНеответивший] + 1;
						КонецЦикла;					
					КонецЕсли;
					
					Если РезультатПроверки.КоличествоАктивных = 0 Тогда
						ЭтоКритическаяОшибка = Истина;
						ТекстОшибки = "Критическая ошибка: не найдено ни одного активного агента" + Символы.ПС + ТекстОшибки;
					КонецЕсли;
					
					// Записать ошибку и отменить выполнение задания, если дальнейшее выполнение невозможно
					Ошибка = ПолучитьСтруктуруОшибки(ТекстОшибки, ВесОшибки, ЭтоКритическаяОшибка);
					ОбработатьОшибку(БуферОшибок, Тест, Агенты, НомерТекущейИтерации, ТекущееКоличествоОшибок, Ошибка);
					
					Если ПредыдущийСценарийЗапуска <> Неопределено Тогда
						Сч = ПредыдущийСценарийЗапуска.Количество() - 1;
						Пока Сч >= 0 Цикл
							ТекущийАгент = ПредыдущийСценарийЗапуска[Сч].Агент;
							
							Если Неотвечающие.Найти(ТекущийАгент) <> Неопределено Тогда
								ПредыдущийСценарийЗапуска.Удалить(Сч);
							КонецЕсли;
							Сч = Сч - 1;
						КонецЦикла;
					КонецЕсли;
					
					Для Каждого ТекущийНеответивший Из Неотвечающие Цикл
						ТекущееКоличествоАгентов = КоличествоАгентовКомпьютеров[ТекущийНеответивший.Компьютер];
						Если ТекущееКоличествоАгентов <> Неопределено Тогда
							КоличествоАгентовКомпьютеров.Вставить(ТекущийНеответивший.Компьютер, ТекущееКоличествоАгентов - 1);
						КонецЕсли;
					КонецЦикла;
					
					АгентыКЗавершению = ТЦСервер.КлиентыЗапущены(Неотвечающие);
					Если АгентыКЗавершению.Количество() > 0 Тогда
						ТЦСервер.УдалитьКлиентов(АгентыКЗавершению);
					КонецЕсли;
					
					Если ТаблицаРаспределения <> Неопределено Тогда
						Для Каждого ТекущийЭлемент Из КоличествоАгентовКомпьютеров Цикл
							ТекущийКомпьютер = ТекущийЭлемент.Ключ;
							Если ТекущийЭлемент.Значение < 1 Тогда
								Сч = ТаблицаРаспределения.Количество() - 1;
								Пока Сч >= 0 Цикл
									Если ТаблицаРаспределения[Сч].Компьютер = ТекущийКомпьютер Тогда
										ТаблицаРаспределения.Удалить(Сч);
									КонецЕсли;
									Сч = Сч - 1;
								КонецЦикла;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
					ЭтоПовторныйРасчет = Истина;
					Продолжить;
					
				КонецЕсли;
				
				СценарийРассчитан = Истина;
				
			КонецЦикла;
			
			СценарийПредыдущейИтерации = ФактическаяСтруктура;

		КонецЕсли;

		Если ТекущееСостояние = Перечисления.ТЦСостояние.Выполнение Тогда
			
			Если НЕ ЭтоДинамическийТест ИЛИ Не ПервыйЭтапВыполненияУжеБыл Тогда
				НачалоТекущегоСостоянияВыполнения = ТекущаяУниверсальнаяДата();
				ПервыйЭтапВыполненияУжеБыл = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
		// Сообщить Агентам о необходимости выполнения задания
		// Подготовить таблицу состояний Агентов
		СостоянияАгентов = Новый ТаблицаЗначений;
		СостоянияАгентов.Колонки.Добавить("Агент");
		СостоянияАгентов.Колонки.Добавить("Выполнено");
		СостоянияАгентов.Колонки.Добавить("Результат");
		СостоянияАгентов.Колонки.Добавить("ВесАгента");
		
		Для каждого Агент Из Агенты Цикл
			СостояниеАгента = СостоянияАгентов.Добавить();
			СостояниеАгента.Агент = Агент;
			СостояниеАгента.Выполнено = Ложь;
			Если ВесаАгентов <> Неопределено Тогда
				СостояниеАгента.ВесАгента = ВесаАгентов[Агент];
			КонецЕсли;
		КонецЦикла;
			
		ОтправитьСообщенияГруппе(
			Агенты,
			Тест,
			Перечисления.ТЦСообщение.Выполнить,
			Задание.Параметры);
			
		Готово = Ложь;
		Таймаут = ТекущаяДата() + Задание.Таймаут + ТаймаутОпросаАгентов + СостоянияАгентов.Количество() * 8; // Таймаут с учетом возможных издержек обмена сообщениями агента и фонового задания
		
		// Ожидать отведенное на запуск время
		Пока ТекущаяДата() < Таймаут Цикл
			
			Если ТекущееСостояние = Перечисления.ТЦСостояние.Подготовка И ОбщееКоличествоОдновременноЗапускаемыхВРМ <> 0 Тогда
				ОтметитьВРМКЗапуску(ОбщееКоличествоОдновременноЗапускаемыхВРМ);
			КонецЕсли;
			
			// Прочитать все сообщения из очереди
			Пока Истина Цикл
				Сообщение = ПолучитьСообщение(Тест);
				
				Если Сообщение = Неопределено Тогда
					Прервать;
				Иначе // Если есть сообщение
					
					СостояниеАгента = СостоянияАгентов.Найти(Сообщение.Отправитель, "Агент");
					Если СостояниеАгента = Неопределено Тогда
						Прервать;
					КонецЕсли;
					
					Если Сообщение.Сообщение = Перечисления.ТЦСообщение.ВыполненоУспешно Тогда
						
						// Отметить успешное выполнение задания одного из Агентов
						СостояниеАгента.Выполнено = Истина;
						СостояниеАгента.Результат = Сообщение.Параметры;
						
					ИначеЕсли Сообщение.Сообщение = Перечисления.ТЦСообщение.ВыполненоСОшибкой Тогда
						
						ЭтоКритическаяОшибка = Ложь;
						ПовторитьПодготовку = Ложь;
						ВесОшибки = 1;
						
						Если ТипЗнч(Сообщение.Параметры) = Тип("Структура") Тогда
							
							СостояниеПриОшибке = Сообщение.Параметры.Состояние;
							Если СостояниеПриОшибке = Перечисления.ТЦСостояние.Подготовка Тогда
								ПовторитьПодготовку = Истина;
							КонецЕсли;
							
							// Сообщение об ошибке изначально появилось на ВРМ
							Если Сообщение.Параметры.Свойство("ВРМ") Тогда
								
								ВРМ = Сообщение.Параметры.ВРМ;
								ТекстОшибки = "Отправитель: " + Строка(ВРМ) + Символы.ПС + Сообщение.Параметры.Результат;
								
							// Сообщение об ошибке от агента	
							Иначе
								
								ТекстОшибки = "Отправитель: " + Сообщение.Отправитель + Символы.ПС + Сообщение.Параметры.Результат;
								ВесОшибки = Сообщение.Параметры.ВесОшибки;
								Если Сообщение.Параметры.Свойство("ЭтоТаймаут") Тогда
									// Отметить выполнение задания одного из Агентов
									// Нужно ли продолжать тест — решает фоновое задание
									СостояниеАгента.Выполнено = Истина;
									СостояниеАгента.Результат = Сообщение.Параметры;
								КонецЕсли;
								
							КонецЕсли;

						ИначеЕсли ТипЗнч(Сообщение.Параметры) = Тип("Строка") Тогда
							ЭтоКритическаяОшибка = Истина;
							ТекстОшибки = "Отправитель: " + Сообщение.Отправитель + Символы.ПС + Сообщение.Параметры;
						КонецЕсли;
						
						// Записать ошибку и отменить выполнение задания, если дальнейшее выполнение невозможно
						Ошибка = ПолучитьСтруктуруОшибки(ТекстОшибки, ВесОшибки, ЭтоКритическаяОшибка);
						ОбработатьОшибку(БуферОшибок, Тест, Агенты, НомерТекущейИтерации, ТекущееКоличествоОшибок, Ошибка);
						
						Если ПовторитьПодготовку Тогда
							ДобавитьПовторнуюПодготовку(НомерТекущейИтерации, ТаблицаВыполнения.Индекс(Задание) + 1, ТаблицаВыполнения, Сценарий, Тест, ПараметрыВыполнения);
						КонецЕсли;
						
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			Готово = Истина;
			
			// Проверить, все ли Агенты выполнили задание
			Для каждого СостояниеАгента Из СостоянияАгентов Цикл
				Если СостояниеАгента.Выполнено = Ложь Тогда
					Готово = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если Готово Тогда
				ОписаниеВРМ = ОписаниеВРМ();
				
				Если ТекущееСостояние = Перечисления.ТЦСостояние.Выполнение	Тогда
					ОкончаниеТекущегоСостоянияВыполнения = ТекущаяУниверсальнаяДата();
					
					// Получим производительность
					ПроизводительностьУдовлетворительна = ПолучитьУдовлетворительностьПроизводительности(НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ПороговыйAPDEX, ТекущаяПроизводительность, ТекущееКоличествоКО);
					
					// Зафиксируем текущую производительность в документе ТЦТест
					ДобавитьПроизводительностьИтерацииВТест(Тест, НомерТекущейИтерации, НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ТекущаяПроизводительность, ТекущееКоличествоКО);

					// Посчитаем по результатам текущей итерации, нужно ли совершать дополнительные итерации 
					Если НомерТекущейИтерации >= МаксимальноеКоличествоИтераций Тогда
						НужныДополнительныеИтерации = Ложь;
					Иначе
						
						Если НЕ ПроизводительностьУдовлетворительна И ТекущийШагДозапускаПользователей <> КонечныйШагДозапускаПользователей И НомерТекущейИтерации <> 1 Тогда
							НужныДополнительныеИтерации = Истина;
							ТекущийШагДозапускаПользователей = КонечныйШагДозапускаПользователей;
							ТекущееКоличествоПользователей = ТекущееКоличествоПользователей - НачальныйШагДозапускаПользователей + ТекущийШагДозапускаПользователей;
						ИначеЕсли НЕ ПроизводительностьУдовлетворительна И (ТекущийШагДозапускаПользователей = КонечныйШагДозапускаПользователей ИЛИ НомерТекущейИтерации = 1)Тогда
							НужныДополнительныеИтерации = Ложь;
						Иначе
							НужныДополнительныеИтерации = Истина;
							ТекущееКоличествоПользователей = ТекущееКоличествоПользователей + ТекущийШагДозапускаПользователей;
						КонецЕсли;
						
					КонецЕсли;
					
					Если НужныДополнительныеИтерации Тогда
						ДополнитьТаблицуВыполнения(НомерТекущейИтерации + 1, ТаблицаВыполнения, Сценарий, Тест, ПараметрыВыполнения);
					Иначе
						
						Если ЭтоДинамическийТест Тогда
							ДобавитьЗаданияЗаписиИУдаления(НомерТекущейИтерации, ТаблицаВыполнения, Сценарий, Тест);
						КонецЕсли;
						
					КонецЕсли;
					
					Если ЭтоДинамическийТест Тогда
						НачалоТекущегоСостоянияВыполнения = ОкончаниеТекущегоСостоянияВыполнения + 1;
					Иначе
						НачалоТекущегоСостоянияВыполнения = Неопределено;
					КонецЕсли;
					
					ОкончаниеТекущегоСостоянияВыполнения = Неопределено;
					
					ТекущееКоличествоОшибок = 0;
				
				КонецЕсли;
				
				Если ТекущееСостояние = Перечисления.ТЦСостояние.ЗаписьРезультатов Тогда
					
					Набор = РегистрыСведений.ТЦРезультаты.СоздатьНаборЗаписей();
					Набор.Отбор.Тест.Установить(Тест);
					НомерПП = 1;
					
					Для каждого СостояниеАгента Из СостоянияАгентов Цикл
						РезультатАгента = СостояниеАгента.Результат;
						
						Если ТипЗнч(РезультатАгента) <> Тип("Соответствие") Тогда
							Продолжить;
						КонецЕсли;
						
						Для каждого СтрокаРезультата Из РезультатАгента Цикл
							ВРМ = СтрокаРезультата.Ключ;
							ЗначенияВРМ = ОписаниеВРМ[ВРМ];
							РезультатВРМ = СтрокаРезультата.Значение.Результат;
							НомерВРМ = СтрокаРезультата.Значение.НомерВРМ;
							
							Если РезультатВРМ = Неопределено Тогда
								Продолжить;
							КонецЕсли;
							
							Для каждого СтрокаПоказателя Из РезультатВРМ Цикл
								НомерПоказателя = 1;
								
								Для каждого ЗначениеПоказателя Из СтрокаПоказателя.Значение Цикл
									СтрокаНабора = Набор.Добавить();
									СтрокаНабора.Номер = НомерПП;
									СтрокаНабора.Тест = Тест;
									СтрокаНабора.Роль = ЗначенияВРМ.ИмяРоли;
									СтрокаНабора.Компьютер = ЗначенияВРМ.Компьютер;
									СтрокаНабора.Пользователь = ЗначенияВРМ.Пользователь;
									СтрокаНабора.НомерВРМ = НомерВРМ;
									СтрокаНабора.Показатель = СтрокаПоказателя.Ключ;
									СтрокаНабора.НомерПоказателя = НомерПоказателя;
									СтрокаНабора.Значение = ЗначениеПоказателя;
									НомерПоказателя = НомерПоказателя + 1;
									НомерПП = НомерПП + 1;
								КонецЦикла;
							КонецЦикла;
						КонецЦикла;
					КонецЦикла;
					
					Набор.ОбменДанными.Загрузка = Истина;
					Набор.Записать();
					
				КонецЕсли;
				
				Прервать;
			Иначе // Если не все Агенты выполнили задание, пауза 3с и повтор проверки
				Если ТестПрерван(Тест) Тогда
					ОтправитьСообщенияГруппе(Агенты,, Перечисления.ТЦСообщение.Отменить);
					
					Если НачалоТекущегоСостоянияВыполнения <> Неопределено И ОкончаниеТекущегоСостоянияВыполнения = Неопределено Тогда
						ОкончаниеТекущегоСостоянияВыполнения = ТекущаяУниверсальнаяДата();
						ПолучитьУдовлетворительностьПроизводительности(НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ПороговыйAPDEX, ТекущаяПроизводительность, ТекущееКоличествоКО);
						ДобавитьПроизводительностьИтерацииВТест(Тест, НомерТекущейИтерации, НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ТекущаяПроизводительность, ТекущееКоличествоКО);
					КонецЕсли;
					
					Возврат;
				КонецЕсли;
				
				КипВнешнийКомпонент.Пауза(Инструменты, 3000);
			КонецЕсли;
		КонецЦикла;
		
		Если Не Готово Тогда
			
			// За отведенное время, не все Агенты выполнили задание, отменить задание
			ОтправитьСообщенияГруппе(Агенты,, Перечисления.ТЦСообщение.Отменить);
			ТекстИсключения = Вычислить(Задание.Ошибка + "(Сценарий, Тест)");
			
			Ошибка = ПолучитьСтруктуруОшибки(ТекстИсключения, 1, Истина);
			ОбработатьОшибку(БуферОшибок, Тест, Агенты, НомерТекущейИтерации, ТекущееКоличествоОшибок, Ошибка);			
						
		ИначеЕсли ТекущееСостояние = Перечисления.ТЦСостояние.Подготовка Тогда
			НачатьТранзакцию();
			НеобходимаПауза = Тест.ПаузаПослеЗапускаВРМ;
			Если НеобходимаПауза Тогда
				ИзменитьТест(Тест, "УстановитьСостояниеЗапускаВРМ", Истина);
			КонецЕсли;
			ЗафиксироватьТранзакцию();
			
			Если НеобходимаПауза Тогда
				Пока Не ТестПрерван(Тест) Цикл
					КипВнешнийКомпонент.Пауза(Инструменты, 3000);
					НачатьТранзакцию();
					ПаузаЗавершена = Не Тест.ПаузаПослеЗапускаВРМ;
					ЗафиксироватьТранзакцию();
					
					Если ПаузаЗавершена Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ИзменитьТест(Тест, "УстановитьСостояниеТеста", ПредопределенноеЗначение("Перечисление.ТЦСостояние.Неактивен"));
	
КонецПроцедуры // ПриВыполненииСценария()

// Получить веса компьютеров (количество ВРМ, соответствующее компьютеру)
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//
// Возвращаемое значение:
//  Соответствие
//
Функция ПолучитьВесаКомпьютеров(СтруктураСценария)
	
	СценарийКопия = СтруктураСценария.Скопировать(, "Клиент,Количество");
	СценарийКопия.Колонки.Добавить("Компьютер", Новый ОписаниеТипов("СправочникСсылка.ТЦКомпьютеры"));

	Для Каждого ТекущаяСтрока Из СценарийКопия Цикл
		ТекущаяСтрока.Компьютер = ТекущаяСтрока.Клиент.Компьютер;
	КонецЦикла;

	СценарийКопия.Свернуть("Компьютер", "Количество");
	
	ВесаКомпьютеров = Новый Соответствие;
	Для Каждого ТекущаяСтрока Из СценарийКопия Цикл
		ВесаКомпьютеров.Вставить(ТекущаяСтрока.Компьютер, ТекущаяСтрока.Количество);
	КонецЦикла;
	
	Возврат ВесаКомпьютеров;
	
КонецФункции

// Получить список компьютеров, на которых не запущены Агенты
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция КомпьютерыБезАгентов(СтруктураСценария)
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("СтруктураСценария", СтруктураСценария);
	Запрос.Текст = "ВЫБРАТЬ
	               |	СтруктураСценария.Клиент КАК Клиент
	               |ПОМЕСТИТЬ ВременнаяСтруктураСценария
	               |ИЗ
	               |	&СтруктураСценария КАК СтруктураСценария
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ РАЗЛИЧНЫЕ
	               |	ВЫРАЗИТЬ(ВременнаяСтруктураСценария.Клиент КАК Справочник.ТЦКлиенты).Компьютер КАК Компьютер
	               |ПОМЕСТИТЬ Компьютеры
	               |ИЗ
	               |	ВременнаяСтруктураСценария КАК ВременнаяСтруктураСценария
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	Компьютеры.Компьютер.Ссылка КАК Ссылка
	               |ИЗ
	               |	Компьютеры КАК Компьютеры
	               |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ТЦАгенты КАК Агенты
	               |		ПО Компьютеры.Компьютер = Агенты.Компьютер
	               |ГДЕ
	               |	Агенты.Компьютер ЕСТЬ NULL ";
				   
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // КомпьютерыБезАгентов()

// Получить список Агентов, задействованных в сценарии
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//
// Возвращаемое значение:
//  Массив - ссылки на агентов, участвующих в тестировании
//
Функция АгентыСценария(СтруктураСценария)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СтруктураСценария", СтруктураСценария);
	Запрос.Текст = "ВЫБРАТЬ
	               |	СтруктураСценария.Клиент КАК Клиент
	               |ПОМЕСТИТЬ ВременнаяСтруктураСценария
	               |ИЗ
	               |	&СтруктураСценария КАК СтруктураСценария
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ РАЗЛИЧНЫЕ
	               |	ВЫРАЗИТЬ(ВременнаяСтруктураСценария.Клиент КАК Справочник.ТЦКлиенты).Компьютер КАК Компьютер
	               |ПОМЕСТИТЬ Компьютеры
	               |ИЗ
	               |	ВременнаяСтруктураСценария КАК ВременнаяСтруктураСценария
	               |
	               |ИНДЕКСИРОВАТЬ ПО
	               |	Компьютер
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	Агенты.Ссылка КАК Ссылка
	               |ИЗ
	               |	Компьютеры КАК Компьютеры
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ТЦАгенты КАК Агенты
	               |		ПО Компьютеры.Компьютер = Агенты.Компьютер";
				   
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // АгентыСценария()

// Возвращает соответствие с весами агентов
//
// Параметры:
//  Агенты - массив
//
// Возвращаемое значение:
//  Соответствие
//		Ключ - СправочникСсылка.ТЦАгенты
//		Значение - Число - вес агента (количество ВРМ агента)
//
Функция ПолучитьВесаАгентов(Агенты)
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦСценарийЗапуска.Агент,
	               |	КОЛИЧЕСТВО(*) КАК ВесАгента
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
	               |ГДЕ
	               |	ТЦСценарийЗапуска.Агент В(&Агенты)
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	ТЦСценарийЗапуска.Агент";
				   
	Запрос.УстановитьПараметр("Агенты", Агенты);
	Выборка = Запрос.Выполнить().Выбрать();
	
	ВесаАгентов = Новый Соответствие;
	Для Каждого ТекАгент Из Агенты Цикл
		
		ВесАгента = 0;
		СтуктураПоиска = Новый Структура("Агент");
		СтуктураПоиска.Агент = ТекАгент;
		Если Выборка.НайтиСледующий(СтуктураПоиска) Тогда
			ВесАгента = Выборка.ВесАгента;
			Выборка.Сбросить();
		КонецЕсли;
		
		ВесаАгентов.Вставить(ТекАгент, ВесАгента);

	КонецЦикла;
	
	Возврат ВесаАгентов;
	
КонецФункции

// Проверить работоспособность Агентов
//
// Параметры:
//  Агенты - Массив Агентов (СправочникСсылка.ТЦАгенты)
//  Тест - ДокументСсылка.Тест
//  ТаймаутОпросаАгентов - Чило
//
//  Возвращаемое значение:
//	   Соответствие:
//		Ключ - СправочникСсылка.ТЦАгенты
//		Значение - Булево - означает активность агента
//
Функция ПроверитьАктивностьАгентов(Агенты, Тест, ТаймаутОпросаАгентов)
	
	РезультатПроверки = Новый Структура;
	РезультатПроверки.Вставить("КоличествоАктивных", 0);
	РезультатПроверки.Вставить("КоличествоНеактивных", 0);
	
	Неполучившие = Новый Массив;
	ПроверкаАктивности = Перечисления.ТЦСообщение.ПроверкаАктивности;
	ОтправитьСообщенияГруппе(Агенты,, ПроверкаАктивности);
	Запрос = ПолучитьЗапросНеДоставленныхСообщений(Агенты);
	Начало = ТекущаяДата();
	Инструменты = КипВнешнийКомпонент.ПолучитьИнструменты();
	
	Пока ТекущаяДата() - Начало < ТаймаутОпросаАгентов Цикл
		Выгрузка = Запрос.Выполнить().Выгрузить();
		Неполучившие = Выгрузка.ВыгрузитьКолонку("Ссылка");
		
		Если Неполучившие.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Если ТестПрерван(Тест) Тогда
			Возврат РезультатПроверки;
		КонецЕсли;
		
		КипВнешнийКомпонент.Пауза(Инструменты, 2000);
	КонецЦикла;
	
	РезультатПроверки.Вставить("Неполучившие", Неполучившие);
	РезультатПроверки.КоличествоАктивных = Агенты.Количество() - Неполучившие.Количество();
	РезультатПроверки.КоличествоНеактивных = Неполучившие.Количество();
	
	Возврат РезультатПроверки;
	
КонецФункции // ПроверитьАктивностьАгентов()

// Сформировать таблицу, на основе которой будет выполняться сценарий
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//	ЭтоДинамическийТест - Булево
//
// Возвращаемое значение:
//  ТаблицаЗначений - Параметры выполнения сценария
//
Функция СформироватьТаблицуВыполнения(Сценарий, Тест, ПараметрыВыполнения)
	
	Таблица = Новый ТаблицаЗначений;
	Колонки = Таблица.Колонки;
	Колонки.Добавить("Параметры");
	Колонки.Добавить("Таймаут");
	Колонки.Добавить("Ошибка");
	Колонки.Добавить("НомерИтерации");
	Колонки.Добавить("ЭтоПовтор");
	
	Задание = Таблица.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Сценарий", Сценарий);
	Параметры.Вставить("Тест", Тест);
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Подготовка);
	Параметры.Вставить("НомерИтерации", 1);
	Параметры.Вставить("ЭтоДинамическийТест",		ПараметрыВыполнения.ЭтоДинамическийТест);
	Параметры.Вставить("КоэффициентИнтенсивности",	ПараметрыВыполнения.КоэффициентИнтенсивности);
	Параметры.Вставить("КоличествоОдновременноЗапускаемыхВРМАгента",	ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента);
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутПодготовки;
	Задание.Ошибка = "ТаймаутПодготовки";
	Задание.НомерИтерации = 1;
	Задание.ЭтоПовтор = Ложь;
	
	Задание = Таблица.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Инициализация);
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутИнициализации;
	Задание.Ошибка = "ТаймаутИнициализации";
	Задание.НомерИтерации = 1;
	Задание.ЭтоПовтор = Ложь;
	
	Задание = Таблица.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Выполнение);
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутВыполнения;
	Задание.Ошибка = "ТаймаутВыполнения";
	Задание.НомерИтерации = 1;
	Задание.ЭтоПовтор = Ложь;
	
	Если Не ПараметрыВыполнения.ЭтоДинамическийТест Тогда
		Задание = Таблица.Добавить();
		Параметры = Новый Структура;
		Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.ЗаписьРезультатов);
		Задание.Параметры = Параметры;
		Задание.Таймаут = Тест.ТаймаутЗаписиРезультатов;
		Задание.Ошибка = "ТаймаутЗаписиРезультатов";
		Задание.НомерИтерации = 1;
		Задание.ЭтоПовтор = Ложь;
		
		Задание = Таблица.Добавить();
		Параметры = Новый Структура;
		Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.УдалениеДанных);
		Задание.Параметры = Параметры;
		Задание.Таймаут = Тест.ТаймаутУдаленияДанных;
		Задание.Ошибка = "ТаймаутУдаленияДанных";
		Задание.НомерИтерации = 1;
		Задание.ЭтоПовтор = Ложь;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции // СформироватьТаблицуВыполнения()

// Добавить задание повторной подготовки в таблицу выполнения
Процедура ДобавитьПовторнуюПодготовку(НомерИтерации, ИндексЗадания, ТаблицаВыполнения, Сценарий, Тест, ПараметрыВыполнения)
	
	Задание = ТаблицаВыполнения.Вставить(ИндексЗадания);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Сценарий", Сценарий);
	Параметры.Вставить("Тест", Тест);
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Подготовка);
	Параметры.Вставить("НомерИтерации", НомерИтерации);
	Параметры.Вставить("ЭтоДинамическийТест", ПараметрыВыполнения.ЭтоДинамическийТест);
	Параметры.Вставить("КоэффициентИнтенсивности", ПараметрыВыполнения.КоэффициентИнтенсивности);
	
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутПодготовки;
	Задание.Ошибка = "ТаймаутПодготовки";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Истина;
	
КонецПроцедуры

// Дополняет таблицу выполнения теста заданиями следующей итерации 
//
// Параметры:
//  ТаблицаВыполнения - ТаблицаЗначений, содержащая задания теста
//  НомерИтерации - Число, номер добавляемой итерации теста
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//  ЭтоДинамическийТест - Булево
//
Процедура ДополнитьТаблицуВыполнения(НомерИтерации, ТаблицаВыполнения, Сценарий, Тест, ПараметрыВыполнения)
	
	Задание = ТаблицаВыполнения.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Сценарий", Сценарий);
	Параметры.Вставить("Тест", Тест);
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Подготовка);
	Параметры.Вставить("НомерИтерации", НомерИтерации);
	Параметры.Вставить("ЭтоДинамическийТест", ПараметрыВыполнения.ЭтоДинамическийТест);
	Параметры.Вставить("КоэффициентИнтенсивности", ПараметрыВыполнения.КоэффициентИнтенсивности);
	Параметры.Вставить("КоличествоОдновременноЗапускаемыхВРМАгента",	ПараметрыВыполнения.КоличествоОдновременноЗапускаемыхВРМАгента);
	
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутПодготовки;
	Задание.Ошибка = "ТаймаутПодготовки";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Ложь;
	
	Задание = ТаблицаВыполнения.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Инициализация);
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутИнициализации;
	Задание.Ошибка = "ТаймаутИнициализации";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Ложь;
	
	Задание = ТаблицаВыполнения.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.Выполнение);
	Задание.Параметры = Параметры;
	Задание.Таймаут = Тест.ТаймаутВыполнения;
	Задание.Ошибка = "ТаймаутВыполнения";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Ложь;
	
	Если Не ПараметрыВыполнения.ЭтоДинамическийТест Тогда
		Задание = ТаблицаВыполнения.Добавить();
		Параметры = Новый Структура;
		Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.ЗаписьРезультатов);
		Задание.Параметры = Параметры;
		Задание.Таймаут = Тест.ТаймаутЗаписиРезультатов;
		Задание.Ошибка = "ТаймаутЗаписиРезультатов";
		Задание.НомерИтерации = НомерИтерации;
		Задание.ЭтоПовтор = Ложь;
		
		Задание = ТаблицаВыполнения.Добавить();
		Параметры = Новый Структура;
		Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.УдалениеДанных);
		Задание.Параметры = Параметры;
		Задание.Таймаут = Тест.ТаймаутУдаленияДанных;
		Задание.Ошибка = "ТаймаутУдаленияДанных";
		Задание.НомерИтерации = НомерИтерации;
		Задание.ЭтоПовтор = Ложь;
	КонецЕсли;

КонецПроцедуры

// Дополняет таблицу выполнения заданиями записью и удалением
//
// Параметры:
//  ТаблицаВыполнения - ТаблицаЗначений, содержащая задания теста
//  НомерИтерации - Число, номер добавляемой итерации теста
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ДобавитьЗаданияЗаписиИУдаления(НомерИтерации, ТаблицаВыполнения, Сценарий, Тест)
	
	Задание = ТаблицаВыполнения.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.ЗаписьРезультатов);
	Задание.Параметры	= Параметры;
	Задание.Таймаут		= Тест.ТаймаутЗаписиРезультатов;
	Задание.Ошибка		= "ТаймаутЗаписиРезультатов";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Ложь;
	
	Задание = ТаблицаВыполнения.Добавить();
	Параметры = Новый Структура;
	Параметры.Вставить("Состояние", Перечисления.ТЦСостояние.УдалениеДанных);
	Задание.Параметры	= Параметры;
	Задание.Таймаут		= Тест.ТаймаутУдаленияДанных;
	Задание.Ошибка		= "ТаймаутУдаленияДанных";
	Задание.НомерИтерации = НомерИтерации;
	Задание.ЭтоПовтор = Ложь;

КонецПроцедуры

// Возвращает масштабированную на целевое количество пользователей структуру сценария
// 
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии - сценарий
//  ЦелевоеКоличествоПользователей  - Число - количество пользователей, которые будут участвовать в сценарии.
//  АдресПубликации - Строка - новый адрес публикации информационной базы,
//                    если строка не пустая будут использованы клиенты, использующие этот адрес.
//                    Если таких клиентов нет в базе, они будут созданы.
//  ЕстьРазделение - Булево - определяет, указывается ли в адресах публикации значение разделения данных.
//  РаспределятьПоКомпьютерамРавномерно - Булево - указывает, нужно ли преобразовывать сценарий к выполнению
//                    на компьютерах, на которых в данный момент запущены агенты.
//						
//  ТаблицаРаспределения - ТаблицаЗначений - определяет веса компьютеров, в соответствии с которыми
//                    будут распределены пользователи.
//                    Поля:
//                           Компьютер - Строка/СправочникСсылка.ТЦКомпьютеры
//                           Вес - Число
//
Функция ПолучитьМасштабированнуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации,
								ЦелевоеКоличествоПользователей = 0,
								АдресПубликации,
								ЕстьРазделение,
								РаспределятьПоКомпьютерамРавномерно,
								ТаблицаРаспределения)

	АдресПубликации = СокрЛП(АдресПубликации);
	ИсходноеКоличествоПользователей = Сценарий.Структура.Итог("Количество");
	
	Если Не ЗначениеЗаполнено(ЦелевоеКоличествоПользователей) Тогда
		ЦелевоеКоличествоПользователей = ИсходноеКоличествоПользователей;
	КонецЕсли;
	
	Если ЦелевоеКоличествоПользователей = 0 ИЛИ ИсходноеКоличествоПользователей = 0 Тогда
		ВызватьИсключение "Не удалось преобразовать сценарий: в сценарии не указано ни одной строки с ненулевым количеством";
	КонецЕсли;
	
	Если РаспределятьПоКомпьютерамРавномерно Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	ТЦАгенты.Компьютер КАК Компьютер,
		               |	1 КАК Вес
		               |ИЗ
		               |	Справочник.ТЦАгенты КАК ТЦАгенты";
					   
		Результат = Запрос.Выполнить();
		
		Если Результат.Пустой() Тогда
			ВызватьИсключение "Не удалось преобразовать сценарий по запущенным агентам: не найдено ни одного агента";
		КонецЕсли;
		
		ТаблицаРаспределения = Результат.Выгрузить();
	ИначеЕсли ТаблицаРаспределения <> Неопределено Тогда
		ТаблицаРаспределения.Свернуть("Компьютер", "Вес");
		
		Для Каждого СтрокаРаспределения из ТаблицаРаспределения Цикл
			Если СтрокаРаспределения.Вес = 0 Тогда
				СтрокаРаспределения.Вес = 1;
			КонецЕсли;
			
			Если ТипЗнч(СтрокаРаспределения.Компьютер) = Тип("Строка") Тогда
				СтрокаРаспределения.Компьютер = ТЦСервер.НайтиКомпьютер(СтрокаРаспределения.Компьютер);
			КонецЕсли;
		КонецЦикла;
		
		Если ТаблицаРаспределения.Количество() = 0 Тогда
			ВызватьИсключение "В таблице распределения ВРМ по компьютерам не осталось ни одной строки."
								"Возможно, все компьютеры были исключены по причине неработоспособности агентов.";
		КонецЕсли;
		
	КонецЕсли;
	
	// Получим исходную структуру сценария масштабированную на целевое количество пользователей
	СтруктураСценария = Новый ТаблицаЗначений;
	СтруктураСценария.Колонки.Добавить("Роль", Новый ОписаниеТипов("СправочникСсылка.ТЦРоли"));
	СтруктураСценария.Колонки.Добавить("Пользователь", Новый ОписаниеТипов("СправочникСсылка.ТЦПользователи")); 
	СтруктураСценария.Колонки.Добавить("Клиент", Новый ОписаниеТипов("СправочникСсылка.ТЦКлиенты")); 
	СтруктураСценария.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦСценарииСтруктура.Роль КАК Роль,
	               |	ТЦСценарииСтруктура.Пользователь КАК Пользователь,
	               |	ТЦСценарииСтруктура.Клиент КАК Клиент,
	               |	СУММА(ТЦСценарииСтруктура.Количество) КАК Количество
	               |ИЗ
	               |	Справочник.ТЦСценарии.Структура КАК ТЦСценарииСтруктура
	               |ГДЕ
	               |	ТЦСценарииСтруктура.Ссылка = &Сценарий
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	ТЦСценарииСтруктура.Роль,
	               |	ТЦСценарииСтруктура.Пользователь,
	               |	ТЦСценарииСтруктура.Клиент
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Количество,
	               |	Роль,
	               |	Пользователь,
	               |	Клиент";
				   
	Запрос.УстановитьПараметр("Сценарий", Сценарий);
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		ВызватьИсключение "Выбран пустой сценарий";
	КонецЕсли;
	
	Если ИсходноеКоличествоПользователей <> ЦелевоеКоличествоПользователей Тогда
		
		ЦелевоеКоличествоПользователейОсталось	= ЦелевоеКоличествоПользователей;
		ИсходноеКоличествоПользователейОсталось	= ИсходноеКоличествоПользователей;
		
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() И ЦелевоеКоличествоПользователейОсталось > 0 Цикл
			
			ТекущееКоличество = Окр(Выборка.Количество * ЦелевоеКоличествоПользователейОсталось / ИсходноеКоличествоПользователейОсталось);
			
			Если ТекущееКоличество > 0 Тогда
				НоваяСтрока = СтруктураСценария.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
				НоваяСтрока.Количество = ТекущееКоличество;
			КонецЕсли;
			
			ЦелевоеКоличествоПользователейОсталось = ЦелевоеКоличествоПользователейОсталось - ТекущееКоличество;
			ИсходноеКоличествоПользователейОсталось = ИсходноеКоличествоПользователейОсталось - Выборка.Количество;
			
		КонецЦикла;
	Иначе
		СтруктураСценария = Результат.Выгрузить();
	КонецЕсли;
	
	Если ТаблицаРаспределения = Неопределено И АдресПубликации = "" Тогда
		Возврат СтруктураСценария;
	КонецЕсли;
	
	Если ТаблицаРаспределения <> Неопределено Тогда
		
		ТаблицаРаспределения.Свернуть("Компьютер", "Вес");
		ТаблицаРаспределения.Сортировать("Вес Возр, Компьютер");
		ТаблицаРаспределения.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
		
		ВесОстаток = ТаблицаРаспределения.Итог("Вес");
		ЦелевоеКоличествоПользователейОстаток = ЦелевоеКоличествоПользователей;
		Для Каждого ТекСтрока Из ТаблицаРаспределения Цикл
			ТекКоличество = Окр(ТекСтрока.Вес * ЦелевоеКоличествоПользователейОстаток / ВесОстаток);
			ТекСтрока.Количество = ТекКоличество;
			
			ВесОстаток = ВесОстаток - ТекСтрока.Вес;
			ЦелевоеКоличествоПользователейОстаток = ЦелевоеКоличествоПользователейОстаток - ТекКоличество;
		КонецЦикла;
		
	КонецЕсли;
		
	ЕстьВеб = Не ПустаяСтрока(АдресПубликации);
	
	УжеБылаИтерация = (СценарийПредыдущейИтерации <> Неопределено);
	Если УжеБылаИтерация Тогда
		
		// Если на одном из компьютеров уже нет агентов, то удалим строки
		// сценария предыдущий итерации с данным компьютером.
		Если ТаблицаРаспределения <> Неопределено
			И СценарийПредыдущейИтерации.Колонки.Найти("Компьютер") <> Неопределено Тогда
			
			Индекс = СценарийПредыдущейИтерации.Количество() - 1;
			Пока Индекс >= 0 Цикл
				
				ТекКомпьютер = СценарийПредыдущейИтерации[Индекс].Компьютер;
				Если ТаблицаРаспределения.Найти(ТекКомпьютер, "Компьютер") = Неопределено Тогда
					СценарийПредыдущейИтерации.Удалить(Индекс);
				КонецЕсли;
				
				Индекс = Индекс - 1;
			КонецЦикла;
			
		КонецЕсли;
		
		СтруктураПредыдущейИтерации = СценарийПредыдущейИтерации.СкопироватьКолонки();
		Для Каждого ТекСтрока Из СценарийПредыдущейИтерации Цикл
			Если ТекСтрока.ЭтоРезерв Или ТекСтрока.Количество < 1 Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = СтруктураПредыдущейИтерации.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекСтрока);
		КонецЦикла;
		
		Если СтруктураПредыдущейИтерации.Колонки.Найти("Компьютер") = Неопределено Тогда
			СтруктураПредыдущейИтерации.Колонки.Добавить("Компьютер", Новый ОписаниеТипов("СправочникСсылка.ТЦКомпьютеры"));
		КонецЕсли;
		
		СтруктураПредыдущейИтерации.Колонки.Добавить("ПолностьюИспользована", Новый ОписаниеТипов("Булево"));
		СтруктураПредыдущейИтерации.Колонки.Добавить("ЗначениеРазделителя");
	КонецЕсли;	
	
	СтруктураСценария.Колонки.Добавить("ЗначениеРазделителя");
	
	ИменаКолонокСценария	= "Роль,Пользователь,ЗначениеРазделителя";
	ИменаКолонокКлиента		= "";
	
	МетаданныеТЦКлиент = Метаданные.Справочники.ТЦКлиенты;
	Для Каждого ТекРеквизит Из МетаданныеТЦКлиент.Реквизиты Цикл
		Если (ТекРеквизит.Имя = "АдресБраузера" и ЕстьВеб)
			Или (ТекРеквизит.Имя = "Компьютер" И НЕ ТаблицаРаспределения = Неопределено)
			Или ТекРеквизит.Имя = "СтрокаЗапуска" Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураСценария.Колонки.Добавить(ТекРеквизит.Имя);
		Если УжеБылаИтерация Тогда
			Если СтруктураПредыдущейИтерации.Колонки.Найти(ТекРеквизит.Имя) = Неопределено Тогда
				СтруктураПредыдущейИтерации.Колонки.Добавить(ТекРеквизит.Имя);
			КонецЕсли;
		КонецЕсли;
		
		ИменаКолонокКлиента = ИменаКолонокКлиента + ?(ПустаяСтрока(ИменаКолонокКлиента), "", ",") + ТекРеквизит.Имя;
	КонецЦикла;
	
	Для Каждого ТекущаяСтрока Из СтруктураСценария Цикл
		
		Клиент = ТекущаяСтрока.Клиент;
		ЗаполнитьЗначенияСвойств(ТекущаяСтрока, Клиент);
		
		Если ЕстьВеб И ЕстьРазделение Тогда
			
			ЗначениеРазделителя = "";
			ЭлементыАдресаБраузера = ТЦОбщий.РазделитьСтроку(Клиент.АдресБраузера, "/");
			
			Если ЭлементыАдресаБраузера.Количество() > 0 Тогда
				ЗначениеРазделителя = ЭлементыАдресаБраузера[ЭлементыАдресаБраузера.ВГраница()];
				Если ПустаяСтрока(ЗначениеРазделителя) Тогда
					ЗначениеРазделителя = ЭлементыАдресаБраузера[ЭлементыАдресаБраузера.ВГраница()-1];
				КонецЕсли;
			КонецЕсли;
			
			ТекущаяСтрока.ЗначениеРазделителя = ЗначениеРазделителя;
		КонецЕсли;
		
	КонецЦикла;
	
	Если УжеБылаИтерация Тогда
		Для Каждого ТекущаяСтрока Из СтруктураПредыдущейИтерации Цикл
			
			Клиент = ТекущаяСтрока.Клиент;
			ЗаполнитьЗначенияСвойств(ТекущаяСтрока, Клиент);
			
			Если ЕстьВеб И ЕстьРазделение Тогда
				
				ЗначениеРазделителя = "";
				ЭлементыАдресаБраузера = ТЦОбщий.РазделитьСтроку(Клиент.АдресБраузера, "/");
				
				Если ЭлементыАдресаБраузера.Количество() > 0 Тогда
					ЗначениеРазделителя = ЭлементыАдресаБраузера[ЭлементыАдресаБраузера.ВГраница()];
					Если ПустаяСтрока(ЗначениеРазделителя) Тогда
						ЗначениеРазделителя = ЭлементыАдресаБраузера[ЭлементыАдресаБраузера.ВГраница()-1];
					КонецЕсли;
				КонецЕсли;
				
				ТекущаяСтрока.ЗначениеРазделителя = ЗначениеРазделителя;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	ИменаКолонок = ИменаКолонокСценария + "," + ИменаКолонокКлиента;
	СтруктураСценария.Свернуть(ИменаКолонок, "Количество");
	
	// Заполним таблицу нового сценария
	ОписаниеНовогоСценария = СтруктураСценария.СкопироватьКолонки();
	Если ОписаниеНовогоСценария.Колонки.Найти("Компьютер") = Неопределено Тогда
		ОписаниеНовогоСценария.Колонки.Добавить("Компьютер");
	КонецЕсли;
	
	Если ЕстьВеб Тогда
		ОписаниеНовогоСценария.Колонки.Добавить("АдресБраузера");
	КонецЕсли;
	
	НоваяСтруктураСценария = Новый ТаблицаЗначений;
	НоваяСтруктураСценария.Колонки.Добавить("Роль", Новый ОписаниеТипов("СправочникСсылка.ТЦРоли"));
	НоваяСтруктураСценария.Колонки.Добавить("Пользователь", Новый ОписаниеТипов("СправочникСсылка.ТЦПользователи")); 
	НоваяСтруктураСценария.Колонки.Добавить("Клиент", Новый ОписаниеТипов("СправочникСсылка.ТЦКлиенты")); 
	НоваяСтруктураСценария.Колонки.Добавить("Компьютер", Новый ОписаниеТипов("СправочникСсылка.ТЦКомпьютеры")); 
	НоваяСтруктураСценария.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	
	Если УжеБылаИтерация Тогда
		Для Каждого ТекСтрока Из СтруктураСценария Цикл
			
			Отбор = Новый Структура(ИменаКолонок);
			Для Каждого ТекЭлементОтбора Из Отбор Цикл
				Ключ = ТекЭлементОтбора.Ключ;
				Отбор[Ключ] = ТекСтрока[Ключ];
			КонецЦикла;
			Отбор.Вставить("ПолностьюИспользована", Ложь);
			
			НайденныеСтроки = СтруктураПредыдущейИтерации.НайтиСтроки(Отбор);
			Если НайденныеСтроки.Количество() > 0 Тогда
				ОсталосьИсходныхВРМ = ТекСтрока.Количество;
				Для Сч = 1 По НайденныеСтроки.Количество() Цикл
					Если ОсталосьИсходныхВРМ = 0 Тогда
						Прервать;
					КонецЕсли;
					
					ТекНайденнаяСтрока = НайденныеСтроки[Сч-1];
					ТекКоличество = Мин(ТекНайденнаяСтрока.Количество, ОсталосьИсходныхВРМ);
					ОсталосьИсходныхВРМ = ОсталосьИсходныхВРМ - ТекКоличество;
					
					НоваяСтрока = НоваяСтруктураСценария.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекНайденнаяСтрока);
					НоваяСтрока.Количество = ТекКоличество;
					
					ТекНайденнаяСтрока.Количество = ТекНайденнаяСтрока.Количество - ТекКоличество;
					Если ТекНайденнаяСтрока.Количество = 0 Тогда
						ТекНайденнаяСтрока.ПолностьюИспользована = Истина;
					КонецЕсли;
				КонецЦикла;
				
				ТекСтрока.Количество = ОсталосьИсходныхВРМ;
			КонецЕсли;
			
		КонецЦикла;
		
		// корректируем количества ВРМ в таблице весов
		Если ТаблицаРаспределения <> Неопределено Тогда
			
			КоличестваСтарыхВРМ = НоваяСтруктураСценария.Скопировать(, "Компьютер,Количество");
			КоличестваСтарыхВРМ.Свернуть("Компьютер", "Количество");
			
			Для Каждого СтрокаВеса из ТаблицаРаспределения Цикл
				
				СтрокаКоличестваСтарыхВРМ = КоличестваСтарыхВРМ.Найти(СтрокаВеса.Компьютер, "Компьютер");
				Если СтрокаКоличестваСтарыхВРМ <> Неопределено Тогда
					СтрокаВеса.Количество = СтрокаВеса.Количество - СтрокаКоличестваСтарыхВРМ.Количество;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТаблицаРаспределения <> Неопределено Тогда
		
		КлючСтрокиСценария = Новый Структура("ИндексСтроки,НомерВРМ", 0, 1);
		Для Каждого СтрокаВеса Из ТаблицаРаспределения Цикл
			
			Для НомерВРМ = 1 По СтрокаВеса.Количество Цикл
				
				СтрокаСценария = ОписаниеНовогоСценария.Добавить();
				СтрокаИсходногоСценария = ПолучитьОписаниеСтрокиСценария(СтруктураСценария, КлючСтрокиСценария);
				
				Если СтрокаИсходногоСценария = Неопределено Тогда
					ВызватьИсключение "Неисправимая ошибка подготовки сценария.";
				КонецЕсли;
				
				ЗаполнитьЗначенияСвойств(СтрокаСценария, СтрокаИсходногоСценария);
				СтрокаСценария.Компьютер = СтрокаВеса.Компьютер;
				
				Если ЕстьВеб Тогда
					СтрокаСценария.АдресБраузера = АдресПубликации + ?(Прав(АдресПубликации, 1) = "/", "", "/") + СтрокаСценария.ЗначениеРазделителя;
				Иначе
					СтрокаСценария.АдресБраузера = СтрокаСценария.АдресБраузера;
				КонецЕсли;
				
				СтрокаСценария.Количество = 1;
				
			КонецЦикла;
			
		КонецЦикла;
		
	Иначе
		
		Для Каждого ТекСтрокаСценария Из СтруктураСценария Цикл
			
			СтрокаСценария = ОписаниеНовогоСценария.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаСценария, ТекСтрокаСценария);
			
			Если ЕстьВеб Тогда
				СтрокаСценария.АдресБраузера = АдресПубликации + ?(Прав(АдресПубликации, 1) = "/", "", "/") + СтрокаСценария.ЗначениеРазделителя;
			Иначе
				СтрокаСценария.АдресБраузера = СтрокаСценария.АдресБраузера;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ИменаКолонокКлиента = ИменаКолонокКлиента + ",Компьютер,АдресБраузера";
	ИменаКолонок = ИменаКолонокСценария + "," + ИменаКолонокКлиента;
	ОписаниеНовогоСценария.Свернуть(ИменаКолонок, "Количество");
	
	Для Каждого ТекущаяСтрока Из ОписаниеНовогоСценария Цикл
		
		НоваяСтрока = НоваяСтруктураСценария.Добавить();
		НоваяСтрока.Роль = ТекущаяСтрока.Роль;
		НоваяСтрока.Пользователь = ТекущаяСтрока.Пользователь;
		
		Клиент = ПолучитьКлиентаПоОписанию(ТекущаяСтрока, ИменаКолонокКлиента, ЕстьВеб, ЕстьРазделение);
		
		НоваяСтрока.Клиент = Клиент;
		НоваяСтрока.Количество = ТекущаяСтрока.Количество;
		
	КонецЦикла;
	
	НоваяСтруктураСценария.Свернуть("Роль,Пользователь,Клиент", "Количество");
	
	Возврат НоваяСтруктураСценария;
							
КонецФункции

// Сформировать таблицу, содержащую структуру резерва ВРМ
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  РазмерРезерваВРМ - Число, количество ВРМ в резерве, выраженное в процентах.
//
// Возвращаемое значение:
// 	ТаблицаЗначений - таблица, описывающая резерв ВРМ. Имеет следующие поля:
// 		Роль - СправочникСсылка.ТЦРоли, роль пользователя в данном сценарии
//		Пользователь - СправочникСсылка.ТЦПользователи, пользователь с данной ролью
//		Клиент - СправочникСсылка.ТЦКлиенты, клиент, с помощью которого данный пользователь подключается к информационной базе
//		Количество - Число, количество клонов, использующих текущее сочетание Роль-Пользователь-Клиент
Функция ПолучитьТаблцицуРезерва(СтруктураСценария, РазмерРезерваВРМ = 0) Экспорт
	
	ТаблицаПула = Новый ТаблицаЗначений;
	ТаблицаПула.Колонки.Добавить("Роль", Новый ОписаниеТипов("СправочникСсылка.ТЦРоли"));
	ТаблицаПула.Колонки.Добавить("Пользователь", Новый ОписаниеТипов("СправочникСсылка.ТЦПользователи")); 
	ТаблицаПула.Колонки.Добавить("Клиент", Новый ОписаниеТипов("СправочникСсылка.ТЦКлиенты")); 
	ТаблицаПула.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число",,,Новый КвалификаторыЧисла(10,0)));
	
	Если РазмерРезерваВРМ = 0 Тогда
		Возврат ТаблицаПула;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	СтруктураСценария.Роль КАК Роль,
	               |	СтруктураСценария.Пользователь КАК Пользователь,
	               |	СтруктураСценария.Клиент КАК Клиент,
	               |	СтруктураСценария.Количество КАК Количество
	               |ПОМЕСТИТЬ ВременнаяСтруктураСценария
	               |ИЗ
	               |	&СтруктураСценария КАК СтруктураСценария
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ВЫРАЗИТЬ(СУММА(ЕСТЬNULL(СтруктураСценария.Количество, 0)) * &РазмерРезерваВРМ / 100 КАК ЧИСЛО(15, 0)) КАК КоличествоРезерва,
	               |	СУММА(СтруктураСценария.Количество) КАК ИсходноеКоличествоОбщее
	               |ИЗ
	               |	ВременнаяСтруктураСценария КАК СтруктураСценария
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	СтруктураСценария.Роль КАК Роль,
	               |	СтруктураСценария.Пользователь КАК Пользователь,
	               |	СтруктураСценария.Клиент КАК Клиент,
	               |	СУММА(СтруктураСценария.Количество) КАК ИсходноеКоличество
	               |ИЗ
	               |	ВременнаяСтруктураСценария КАК СтруктураСценария
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	СтруктураСценария.Роль,
	               |	СтруктураСценария.Пользователь,
	               |	СтруктураСценария.Клиент
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ИсходноеКоличество,
	               |	Роль,
	               |	Клиент,
	               |	Пользователь";
				   
	Запрос.УстановитьПараметр("СтруктураСценария", СтруктураСценария);
	Запрос.УстановитьПараметр("РазмерРезерваВРМ", РазмерРезерваВРМ);
	
	МассивРезультатов = Запрос.ВыполнитьПакет();
	Если МассивРезультатов.Количество() <> 3 Тогда
		Возврат ТаблицаПула;
	КонецЕсли;
	
	Результат = МассивРезультатов[1];
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	
	ЦелевоеКоличество = Выборка.КоличествоРезерва;
	ОсталостьНабратьПользователей = Выборка.КоличествоРезерва;
	ИсходноеКоличествоОбщее = Выборка.ИсходноеКоличествоОбщее;
	
	Результат = МассивРезультатов[2];
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() И ОсталостьНабратьПользователей > 0 Цикл
		
		ТекущееКоличество = Окр(ЦелевоеКоличество * Выборка.ИсходноеКоличество / ИсходноеКоличествоОбщее);
		
		Если ТекущееКоличество > 0 Тогда
			НоваяСтрока = ТаблицаПула.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
			НоваяСтрока.Количество = ТекущееКоличество;
		КонецЕсли;
		
		ОсталостьНабратьПользователей = ОсталостьНабратьПользователей - ТекущееКоличество;
		
	КонецЦикла;
	
	Возврат ТаблицаПула;
	
КонецФункции

// Возвращает фактическую структуру сценария
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии - сценарий
//  ЦелевоеКоличествоПользователей  - Число - количество пользователей, которые будут участвовать в сценарии.
//  РазмерРезерва   - Число - размер резерва ВРМ, указанный в процентах
//  АдресПубликации - Строка - новый адрес публикации информационной базы,
//                    если строка не пустая будут использованы клиенты, использующие этот адрес.
//                    Если таких клиентов нет в базе, они будут созданы.
//  ЕстьРазделение - Булево - определяет, указывается ли в адресах публикации значение разделения данных.
//  РаспределятьПоКомпьютерамРавномерно - Булево - указывает, нужно ли преобразовывать сценарий к выполнению
//                    на компьютерах, на которых в данный момент запущены агенты.
//						
//  ТаблицаРаспределения - ТаблицаЗначений - определяет веса компьютеров, в соответствии с которыми
//                    будут распределены пользователи.
//                    Поля:
//                           Компьютер - Строка/СправочникСсылка.ТЦКомпьютеры
//                           Вес - Число
//
Функция ПолучитьФактическуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации, ТекущееКоличествоПользователей, РазмерРезерва, АдресПубликации, ЕстьРазделение, РаспределятьПоКомпьютерамРавномерно, ТаблицаРаспределения)

	// Рассчитаем текущий сценарий выполнения по начальному количеству пользователей
	МасштабированнаяСтруктураСценария = ПолучитьМасштабированнуюСтруктуруСценария(Сценарий, СценарийПредыдущейИтерации, ТекущееКоличествоПользователей, АдресПубликации, ЕстьРазделение, РаспределятьПоКомпьютерамРавномерно, ТаблицаРаспределения);

	// Рассчитаем таблицу резерва ВРМ (пула)
	ТаблицаРезерва = ПолучитьТаблцицуРезерва(МасштабированнаяСтруктураСценария, РазмерРезерва);
	
	// Добавим в масштабированную структуру строки с резервом ВРМ
	МасштабированнаяСтруктураСценария.Колонки.Добавить("ЭтоРезерв", Новый ОписаниеТипов("Булево"));
	Если ТаблицаРезерва.Количество() > 0 Тогда
		
		Для Каждого СтрокаРезерва Из ТаблицаРезерва Цикл
			
			НоваяСтрока = МасштабированнаяСтруктураСценария.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаРезерва);
			НоваяСтрока.ЭтоРезерв = Истина;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МасштабированнаяСтруктураСценария;

КонецФункции // ПолучитьФактическуюСтруктуруСценария(Сценарий, ТекущееКоличествоПользователей, РазмерРезерва, АдресПубликации, ЕстьРазделение, РаспределятьПоКомпьютерамРавномерно, ТаблицаРаспределения)()

// Отмечает указанное количество ВРМ как готовые к запуску
//
// Параметры:
//  ОбщееКоличествоОдновременноЗапускаемыхВРМ  - Число
//
Процедура ОтметитьВРМКЗапуску(ОбщееКоличествоОдновременноЗапускаемыхВРМ) 

	НачатьТранзакцию();
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЕСТЬNULL(СУММА(ВЫБОР
	               |				КОГДА ТЦСценарийЗапуска.Запущен = 1
	               |					ТОГДА 1
	               |			КОНЕЦ), 0) КАК КоличествоГотовых,
	               |	ЕСТЬNULL(СУММА(ВЫБОР
	               |				КОГДА ТЦСценарийЗапуска.Запущен = 0
	               |					ТОГДА 1
	               |			КОНЕЦ), 0) КАК КоличествоНеготовых
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска";
	
	Выборка = Запрос.Выполнить().Выбрать();
	ЗафиксироватьТранзакцию();
	
	Выборка.Следующий();	
	
	ВРМКОтметке = Мин(ОбщееКоличествоОдновременноЗапускаемыхВРМ - Выборка.КоличествоГотовых, Выборка.КоличествоНеготовых);
	
	Если ВРМКОтметке > 0 Тогда
		
		Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ " + Формат(ВРМКОтметке, "ЧГ=0") + " 
		               |	ТЦСценарийЗапуска.Ид КАК Ид
		               |ИЗ
		               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
		               |ГДЕ
		               |	ТЦСценарийЗапуска.Запущен = 0";
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			ОтметитьГотовоКЗапуску(Выборка.Ид);
		КонецЦикла;
		
	КонецЕсли;
	

КонецПроцедуры // ОтметитьВРМКЗапуску()

// Подготовить сценарий для запуска
//
// Параметры:
//  Сценарий - СправочникСсылка.Сценарии
//
Процедура ПодготовитьСценарийЗапуска(СтруктураСценария, ИспользоватьТолькоКлонов, ПредыдущийСценарийЗапуска, ЭтоДинамическийТест = Ложь, ОбщееКоличествоОдновременноЗапускаемыхВРМ = 0) Экспорт
	
	// Очистить таблицу запуска
	СценарийЗапуска = РегистрыСведений.ТЦСценарийЗапуска.СоздатьНаборЗаписей();
	СценарийЗапуска.ОбменДанными.Загрузка = Истина;
	СценарийЗапуска.Записать();
	
	// Заполним карта клонов
	Если ПредыдущийСценарийЗапуска = Неопределено Тогда
		БылПредыдущийЗапуск = Ложь;
	Иначе
		БылПредыдущийЗапуск = ПредыдущийСценарийЗапуска.Количество() > 0;		
	КонецЕсли;
	
	// Получить сценарий
	СтруктураСценария.Свернуть("Пользователь,Клиент,Роль,ЭтоРезерв", "Количество");
	
	ТаблицаКоличестваКлонов = СтруктураСценария.Скопировать(,"Пользователь,Количество");
	ТаблицаКоличестваКлонов.Свернуть("Пользователь", "Количество");
	
	ТаблицаКоличестваВРМ = СтруктураСценария.Скопировать(,"Роль,Количество");
	ТаблицаКоличестваВРМ.Свернуть("Роль", "Количество");
	
	Если СтруктураСценария.Колонки.Найти("Компьютер") = Неопределено Тогда
		СтруктураСценария.Колонки.Добавить("Компьютер", Новый ОписаниеТипов("СправочникСсылка.ТЦКомпьютеры"));
	КонецЕсли;
	
	Для Каждого СтрокаСценария Из СтруктураСценария Цикл
		СтрокаСценария.Компьютер = СтрокаСценария.Клиент.Компьютер;
	КонецЦикла;
	
	СтруктураСценария.Сортировать("Компьютер,Пользователь,Клиент,Роль");
	
	// Заполним таблицу, содержащую свободные номера ВРМ
	СвободныеНомераВРМ = Новый ТаблицаЗначений;
	СвободныеНомераВРМ.Колонки.Добавить("Роль", Новый ОписаниеТипов("СправочникСсылка.ТЦРоли"));
	СвободныеНомераВРМ.Колонки.Добавить("Номера", Новый ОписаниеТипов("Массив"));
	СвободныеНомераВРМ.Колонки.Добавить("ИндексСвободного", Новый ОписаниеТипов("Число",,, Новый КвалификаторыЧисла(10))); // Указывает на первого незанятятого клона
	
	// Заполняем таблицу свободных номеров ВРМ
	Для Каждого ТекущаяСтрока Из ТаблицаКоличестваВРМ Цикл
		
		МаксимальныйНомер	= ТекущаяСтрока.Количество;
		
		НоваяСтрока = СвободныеНомераВРМ.Добавить();
		НоваяСтрока.Роль = ТекущаяСтрока.Роль;
		НоваяСтрока.ИндексСвободного = 0;
		
		СвободныеНомера = Новый Массив;
		Для Сч = 1 По МаксимальныйНомер Цикл
			
			Если БылПредыдущийЗапуск Тогда
				СтруктураОтбора = Новый Структура;
				СтруктураОтбора.Вставить("Роль", ТекущаяСтрока.Роль);
				СтруктураОтбора.Вставить("Номер", Сч);
				
				// Помечаем номер ВРМ как свободный только в случае, если он не использовался на предыдущих итерациях
				НайденныеСтроки = ПредыдущийСценарийЗапуска.НайтиСтроки(СтруктураОтбора);
				Если НайденныеСтроки.Количество() = 0 Тогда
					СвободныеНомера.Добавить(Сч);
				КонецЕсли;
			Иначе
				СвободныеНомера.Добавить(Сч);
			КонецЕсли;
			
		КонецЦикла;
		
		НоваяСтрока.Номера = СвободныеНомера;
		
	КонецЦикла;
	
	// Выполнить начальное заполнение таблицы запуска с размножением количества 
	// и установить номера ВРМ
	Для Каждого СтрокаСценария Из СтруктураСценария Цикл
		
		Для Сч = 1 По СтрокаСценария.Количество Цикл
			
			ЭлементЗапуска = СценарийЗапуска.Добавить();
			ЭлементЗапуска.Ид = Новый УникальныйИдентификатор();
			ЭлементЗапуска.Компьютер = СтрокаСценария.Компьютер;
			ЭлементЗапуска.Роль = СтрокаСценария.Роль;
			ЭлементЗапуска.Клиент = СтрокаСценария.Клиент;
			ЭлементЗапуска.Пользователь = СтрокаСценария.Пользователь;
			
			Если ОбщееКоличествоОдновременноЗапускаемыхВРМ = 0 Тогда
				ЭлементЗапуска.Запущен = 1; // по-умолчанию ВРМ готовы к запуску
			Иначе
				ЭлементЗапуска.Запущен = 0;
			КонецЕсли;
			
			ЭлементЗапуска.ПродолжатьРаботуМеждуИтерациями = ЭтоДинамическийТест;
			
			Если СтрокаСценария.ЭтоРезерв Тогда
				ЭлементЗапуска.Состояние = Перечисления.ТЦСостояние.Резерв;
			КонецЕсли;
			
			// Найдем подходящие данные из предыдущего запуска
			Если БылПредыдущийЗапуск Тогда
				СтруктураОтбора = Новый Структура;
				СтруктураОтбора.Вставить("Роль", СтрокаСценария.Роль);
				СтруктураОтбора.Вставить("Пользователь", СтрокаСценария.Пользователь);
				СтруктураОтбора.Вставить("Клиент", СтрокаСценария.Клиент);
				СтруктураОтбора.Вставить("Использован", Ложь);
				
				НайденныеСтроки = ПредыдущийСценарийЗапуска.НайтиСтроки(СтруктураОтбора);
				Если НайденныеСтроки.Количество() > 0 Тогда
					СтрокаПредыдущегоЗапуска = НайденныеСтроки[0];
					
					ЭлементЗапуска.Агент	= СтрокаПредыдущегоЗапуска.Агент;
					ЭлементЗапуска.НомерСессии = СтрокаПредыдущегоЗапуска.НомерСессии;
					ЭлементЗапуска.Клон		= СтрокаПредыдущегоЗапуска.Клон;
					ЭлементЗапуска.Номер	= СтрокаПредыдущегоЗапуска.Номер;
					
					СтрокаПредыдущегоЗапуска.Использован = Истина;
				КонецЕсли;
			КонецЕсли;
			
			// Установим номер ВРМ
			Если Не ЗначениеЗаполнено(ЭлементЗапуска.Номер) Тогда
				
				СтрокаСвободныхНомеров = СвободныеНомераВРМ.Найти(СтрокаСценария.Роль, "Роль");
				Если СтрокаСвободныхНомеров = Неопределено Тогда
					ВызватьИсключение "Ошибка подготовки таблицы запуска: не найдено свободных номеров ВРМ для роли " + СокрЛП(СтрокаСценария.Роль) + ", пользователь: " + СокрЛП(СтрокаСценария.Пользователь);
				КонецЕсли;
				
				Если СтрокаСвободныхНомеров.Номера.Количество() <= СтрокаСвободныхНомеров.ИндексСвободного Тогда
					ВызватьИсключение "Ошибка подготовки таблицы запуска: не найдено свободных номеров ВРМ для роли " + СокрЛП(СтрокаСценария.Роль) + ", пользователь: " + СокрЛП(СтрокаСценария.Пользователь);
				КонецЕсли;
				
				ЭлементЗапуска.Номер = СтрокаСвободныхНомеров.Номера[СтрокаСвободныхНомеров.ИндексСвободного];
				СтрокаСвободныхНомеров.ИндексСвободного = СтрокаСвободныхНомеров.ИндексСвободного + 1;

			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;

	// Заполним таблицу, содержащую номера свободных клонов
	ТаблицаСвободныхКлонов = Новый ТаблицаЗначений;
	ТаблицаСвободныхКлонов.Колонки.Добавить("Пользователь", Новый ОписаниеТипов("СправочникСсылка.ТЦПользователи"));
	ТаблицаСвободныхКлонов.Колонки.Добавить("Клоны", Новый ОписаниеТипов("Массив"));
	ТаблицаСвободныхКлонов.Колонки.Добавить("ИндексСвободного", Новый ОписаниеТипов("Число",,, Новый КвалификаторыЧисла(10))); // Указывает на первого незанятятого клона
	
	// Заполняем таблицу свободных клонов
	Для Каждого ТекущаяСтрока Из ТаблицаКоличестваКлонов Цикл
		
		МаксимальныйНомер	= ТекущаяСтрока.Количество;
		
		Если МаксимальныйНомер > 1 ИЛИ ИспользоватьТолькоКлонов Тогда
			НоваяСтрока = ТаблицаСвободныхКлонов.Добавить();
			НоваяСтрока.Пользователь = ТекущаяСтрока.Пользователь;
			НоваяСтрока.ИндексСвободного = 0;
			
			СвободныеКлоны = Новый Массив;
			Для Сч = 1 По МаксимальныйНомер Цикл
				КлонИБ = КлонПользователя(ТекущаяСтрока.Пользователь.ИдентификаторПользователяИБ, Сч);
				ТекущийКлон = ПользовательИБПоИдентификатору(Строка(КлонИБ.УникальныйИдентификатор));
				
				Если БылПредыдущийЗапуск Тогда
					СтруктураОтбора = Новый Структура;
					СтруктураОтбора.Вставить("Клон", ТекущийКлон);
					
					// Помечаем клона как свободного только в случае, если он не использовался на предыдущих итерациях
					НайденныеСтроки = ПредыдущийСценарийЗапуска.НайтиСтроки(СтруктураОтбора);
					Если НайденныеСтроки.Количество() = 0 Тогда
						СвободныеКлоны.Добавить(ТекущийКлон);
					КонецЕсли;
				Иначе
					СвободныеКлоны.Добавить(ТекущийКлон);
				КонецЕсли;
			КонецЦикла;
		
			НоваяСтрока.Клоны = СвободныеКлоны;
		КонецЕсли;
		
	КонецЦикла;
	
	// Распределить ВП по Агентам
	// Получить список агентов разделенный по компьютерам
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦАгенты.Компьютер,
	               |	ТЦАгенты.НомерСессии,
	               |	ТЦАгенты.Ссылка
	               |ИЗ
	               |	Справочник.ТЦАгенты КАК ТЦАгенты
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТЦАгенты.Компьютер,
	               |	ТЦАгенты.НомерСессии";
				   
	Выборка = Запрос.Выполнить().Выбрать();
	
	Компьютеры = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		Если Компьютеры[Выборка.Компьютер] = Неопределено Тогда
			Компьютеры[Выборка.Компьютер] = Новый Массив;
		КонецЕсли;
		
		ОписаниеАгента = Новый Структура("Агент, НомерСессии");
		ОписаниеАгента.Агент = Выборка.Ссылка;
		ОписаниеАгента.НомерСессии = Выборка.НомерСессии;
		Компьютеры[Выборка.Компьютер].Добавить(ОписаниеАгента);
	КонецЦикла;
	
	ТекущийКомпьютер = Неопределено;
	НомерАгента = 0;
	
	Для Каждого ЗапускаемыйВП Из СценарийЗапуска Цикл
		
		Если ТекущийКомпьютер <> ЗапускаемыйВП.Компьютер Тогда
			ТекущийКомпьютер = ЗапускаемыйВП.Компьютер;
			АгентыКомпьютера = Компьютеры[ТекущийКомпьютер];
			НомерАгента = 0;
		КонецЕсли;
		
		ОписаниеАгента		= АгентыКомпьютера[НомерАгента];
		
		Если Не ЗначениеЗаполнено(ЗапускаемыйВП.Клон) Тогда
			ТекущаяСессия		= ОписаниеАгента.НомерСессии;
			ТекущийКлиент 		= ЗапускаемыйВП.Клиент;
			ТекущийПользователь = ЗапускаемыйВП.Пользователь;
			ТекущийКлонЗапуска	= Справочники.ТЦПользователи.ПустаяСсылка();
			
			ЗапускаемыйВП.Агент = ОписаниеАгента.Агент;
			ЗапускаемыйВП.НомерСессии = ТекущаяСессия;
			
			// Определим, нужно ли использовать оригинального пользователя, или нужно использовать клона
			СтрокаТаблицы = ТаблицаКоличестваКлонов.Найти(ТекущийПользователь, "Пользователь");
			Если СтрокаТаблицы.Количество > 1 ИЛИ ИспользоватьТолькоКлонов Тогда // Нужно использовать клона
				
				СтрокаТаблицыСвободныхКлонов = ТаблицаСвободныхКлонов.Найти(ТекущийПользователь, "Пользователь");
				Если СтрокаТаблицыСвободныхКлонов = Неопределено Тогда
					ВызватьИсключение "Ошибка подготовки таблицы запуска: не найдено свободных клонов для пользователя " + СокрЛП(ТекущийПользователь);						
				КонецЕсли;
				
				Если СтрокаТаблицыСвободныхКлонов.Клоны.Количество() <= СтрокаТаблицыСвободныхКлонов.ИндексСвободного Тогда
					ВызватьИсключение "Ошибка подготовки таблицы запуска: не найдено свободных клонов для пользователя " + СокрЛП(ТекущийПользователь);						
				КонецЕсли;
				
				ТекущийКлонЗапуска = СтрокаТаблицыСвободныхКлонов.Клоны[СтрокаТаблицыСвободныхКлонов.ИндексСвободного];
				СтрокаТаблицыСвободныхКлонов.ИндексСвободного = СтрокаТаблицыСвободныхКлонов.ИндексСвободного + 1;
				
			Иначе // Используем оригинального пользователя
				ТекущийКлонЗапуска = ТекущийПользователь;
			КонецЕсли;
			
			ЗапускаемыйВП.Клон = ТекущийКлонЗапуска;
			
		Иначе
			
			НомерАгента = 0;
			КоличествоАгентов = АгентыКомпьютера.ВГраница();
			Для Сч = 0 По КоличествоАгентов Цикл
				Если АгентыКомпьютера[Сч].Агент = ЗапускаемыйВП.Агент И АгентыКомпьютера[Сч].НомерСессии = ЗапускаемыйВП.НомерСессии Тогда
					НомерАгента = Сч;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
		Если НомерАгента < АгентыКомпьютера.Количество() - 1 Тогда
			НомерАгента = НомерАгента + 1;
		Иначе
			НомерАгента = 0;
		КонецЕсли;
		
	КонецЦикла;
	
	// Выгрузим сценарий запука, что потом использовать как предыдущий сценарий для корректного переиспользования ВРМ
	ПредыдущийСценарийЗапуска = СценарийЗапуска.Выгрузить(, "Компьютер,Агент,НомерСессии,Клиент,Пользователь,Роль,Номер,Клон");
	ПредыдущийСценарийЗапуска.Колонки.Добавить("Использован", Новый ОписаниеТипов("Булево"));
	ПредыдущийСценарийЗапуска.Индексы.Добавить("Роль,Пользователь,Клиент,Использован");
	ПредыдущийСценарийЗапуска.Индексы.Добавить("Роль,Номер");
	ПредыдущийСценарийЗапуска.Индексы.Добавить("Клон");
	
	СценарийЗапуска.ОбменДанными.Загрузка = Истина;
	СценарийЗапуска.Записать();
	
КонецПроцедуры // ПодготовитьСценарий()

// Считает APDEX за указанный период теста, если полученное значение меньше указанного в параметре ПороговыйAPDEX возвращается Ложь, иначе возвращается Истина
//
// Параметы:
//  НачалоТекущегоСостоянияВыполнения - Дата, начало периода замеров, по которым будет рассчитан APDEX
//  ОкончаниеТекущегоСостоянияВыполнения - Дата, окончание периода замеров, по которым будет рассчитан APDEX
//  ПороговыйAPDEX - Число, значение показателя APDEX, ниже которого выполнения теста необходимо закончить
//	ТекущаяПроизводительность - Число, в параметр записывается вычисленный APDEX
//	ТекущееКоличествоКО - Число, в параметр ТекущееКоличествоКО записывается количество замеров ключевых операций
Функция ПолучитьУдовлетворительностьПроизводительности(НачалоТекущегоСостоянияВыполнения, ОкончаниеТекущегоСостоянияВыполнения, ПороговыйAPDEX, ТекущаяПроизводительность, ТекущееКоличествоКО)
	
	Если НЕ ОценкаПроизводительностиИспользуется() Тогда
		ТекущаяПроизводительность = 0;
		ТекущееКоличествоКО = 0;
		Возврат Истина;		
	КонецЕсли;
	
	Если ПороговыйAPDEX > 1 ИЛИ ПороговыйAPDEX < 0 Тогда
		ТекущаяПроизводительность = 0;
		ТекущееКоличествоКО = 0;
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЕСТЬNULL(СУММА(ВЫБОР
	               |				КОГДА ЗамерыВремени.ВремяВыполнения <= ЗамерыВремени.КлючеваяОперация.ЦелевоеВремя
	               |					ТОГДА 1
	               |				КОГДА ЗамерыВремени.ВремяВыполнения <= 4 * ЗамерыВремени.КлючеваяОперация.ЦелевоеВремя
	               |					ТОГДА 0.5
	               |				ИНАЧЕ 0
	               |			КОНЕЦ) / ВЫБОР
	               |			КОГДА КОЛИЧЕСТВО(*) = 0
	               |				ТОГДА 1
	               |			ИНАЧЕ КОЛИЧЕСТВО(*)
	               |		КОНЕЦ, 0) КАК APDEX,
	               |	КОЛИЧЕСТВО(*) КАК КоличествоКО
	               |ИЗ
	               |	РегистрСведений.ЗамерыВремени КАК ЗамерыВремени
	               |ГДЕ
	               |	ЗамерыВремени.ДатаЗаписи МЕЖДУ &ДатаНачалаЗамеров И &ДатаОкончанияЗамеров";
				   
	Запрос.УстановитьПараметр("ДатаНачалаЗамеров", НачалоТекущегоСостоянияВыполнения);
	Запрос.УстановитьПараметр("ДатаОкончанияЗамеров", ОкончаниеТекущегоСостоянияВыполнения);
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		ТекущаяПроизводительность = 0;
		ТекущееКоличествоКО = 0;
		Возврат Ложь;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	
	ТекущаяПроизводительность = Выборка.APDEX;
	ТекущееКоличествоКО = Выборка.КоличествоКО;
	
	Если Выборка.APDEX < ПороговыйAPDEX Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Получить список ВРМ не подходящих для запускаемого сценария
//
// Параметры:
//  Компьютер - Строка, имя компьютера
//  НомерСессии - Число, номер сесси в которой запущены ВРМ
//
// Возвращаемое значение:
//  Массив - ссылки на неподходящие ВРМ
//
Функция ВРМВнеСценария(Компьютер, НомерСессии) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", НайтиКомпьютер(Компьютер));
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ВП.Ссылка КАК Ссылка,
	               |	ВП.Клиент КАК Клиент,
	               |	ВП.НомерСессии КАК НомерСессии,
	               |	ВП.Клон КАК Клон
	               |ПОМЕСТИТЬ СписокВРМ
	               |ИЗ
	               |	Справочник.ТЦВП КАК ВП
	               |ГДЕ
	               |	ВП.Компьютер = &Компьютер
	               |	И ВП.НомерСессии = &НомерСессии
	               |
	               |ИНДЕКСИРОВАТЬ ПО
	               |	ВП.Клиент,
	               |	ВП.НомерСессии,
	               |	ВП.Клон
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ВП.Ссылка КАК ВРМ
	               |ИЗ
	               |	СписокВРМ КАК ВП
	               |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ТЦСценарийЗапуска КАК СценарийЗапуска
	               |		ПО (СценарийЗапуска.Компьютер = &Компьютер)
	               |			И (СценарийЗапуска.НомерСессии = &НомерСессии)
	               |			И ВП.Клиент = СценарийЗапуска.Клиент
	               |			И ВП.НомерСессии = СценарийЗапуска.НомерСессии
	               |			И ВП.Клон = СценарийЗапуска.Клон
	               |ГДЕ
	               |	СценарийЗапуска.Запущен ЕСТЬ NULL ";
		
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ВРМ");
	
КонецФункции // ВРМВнеСценария()

// Заполняет соответствие представлений ВРМ. Используется для диагностических ошибок, если ошибки связаны с уже выключенными ВРМ.
//
// Параметры:
//  мПредставленияВРМ - Соответствие
//  Компьютер - Строка, имя компьютера
//  НомерСессии - Число, номер сесси в которой запущены ВРМ
//
Процедура ОбновитьПредставленияВРМ(мПредставленияВРМ, ИмяЭтогоКомпьютера, НомерСессии) Экспорт
	
	Если мПредставленияВРМ = Неопределено Тогда
		мПредставленияВРМ = Новый Соответствие;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", НайтиКомпьютер(ИмяЭтогоКомпьютера));
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.Текст = "ВЫБРАТЬ
	               |	ВП.Ссылка КАК Ссылка,
	               |	ПРЕДСТАВЛЕНИЕ(ВП.Ссылка) КАК Представление
	               |ИЗ
	               |	Справочник.ТЦВП КАК ВП
	               |ГДЕ
	               |	ВП.Компьютер = &Компьютер
	               |	И ВП.НомерСессии = &НомерСессии";
				   
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		 Возврат;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		мПредставленияВРМ.Вставить(Выборка.Ссылка, Выборка.Представление);
	КонецЦикла;
	
КонецПроцедуры // ОбновитьПредставленияВРМ()

// Пометить подходящие ВРМ, как уже запущенные
//
// Параметры:
//  Компьютер - СправочникСсылка, компьютер на котором запущены ВРМ
//  НомерСессии - Число, номер сесси в которой запущены ВРМ
//  ПродолжающиеРаботуВРМ — массив элементов СправочникСсылка.ТЦВП
//
Функция ПереиспользоватьВРМ(Компьютер, НомерСессии, ПродолжающиеРаботуВРМ) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", НайтиКомпьютер(Компьютер));
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.Текст = "ВЫБРАТЬ
	               |	ВП.Ссылка КАК ВРМ,
	               |	СценарийЗапуска.Ид КАК ИдЭлементаСценария,
	               |	СценарийЗапуска.Роль КАК РольЭлементаСценария,
	               |	СценарийЗапуска.Номер КАК Номер
	               |ИЗ
	               |	Справочник.ТЦВП КАК ВП
	               |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ТЦСценарийЗапуска КАК СценарийЗапуска
	               |		ПО (СценарийЗапуска.Компьютер = &Компьютер)
	               |			И (СценарийЗапуска.НомерСессии = &НомерСессии)
	               |			И ВП.Клиент = СценарийЗапуска.Клиент
	               |			И ВП.НомерСессии = СценарийЗапуска.НомерСессии
	               |			И ВП.Клон = СценарийЗапуска.Клон
	               |ГДЕ
	               |	СценарийЗапуска.Запущен ЕСТЬ НЕ NULL 
	               |	И ВП.Состояние <> ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Выгрузка)";
				   
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	НомераВРМ = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		
		НачатьТранзакцию();
		
		Если ПродолжающиеРаботуВРМ <> Неопределено
			И ПродолжающиеРаботуВРМ.Найти(Выборка.ВРМ) = Неопределено Тогда
		
			ОбъектВП = Выборка.ВРМ.ПолучитьОбъект();
			ОбъектВП.Роль = Выборка.РольЭлементаСценария;
			Если ОбъектВП.Состояние <> Перечисления.ТЦСостояние.Резерв Тогда
				ОбъектВП.Состояние = Перечисления.ТЦСостояние.Неактивен;
			КонецЕсли;
			
			ОбъектВП.ОбменДанными.Загрузка = Истина;
			ОбъектВП.Записать();
			
		КонецЕсли;
		
		СтрокиСценарияЗапуска = РегистрыСведений.ТЦСценарийЗапуска.СоздатьНаборЗаписей();
		СтрокиСценарияЗапуска.Отбор.Ид.Установить(Выборка.ИдЭлементаСценария);
		СтрокиСценарияЗапуска.Прочитать();
		Если СтрокиСценарияЗапуска.Количество() > 0 Тогда
			СтрокиСценарияЗапуска[0].Запущен = 2;
			СтрокиСценарияЗапуска.ОбменДанными.Загрузка = Истина;
			СтрокиСценарияЗапуска.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		НомераВРМ[Выборка.ВРМ] = Выборка.Номер;
	КонецЦикла;
	
	Возврат НомераВРМ;
	
КонецФункции // ПереиспользоватьВРМ()

// Получить соответствие ВРМ и его Роли
//
// Параметры:
//  СписокВРМ - Массив
//
// Возвращаемое значение:
//  Соответствие:
//   Ключ - Справочник.ТЦВП
//   Значение - Справочник.ТЦРоли
//
Функция РолиВРМ(СписокВРМ) Экспорт
	
	РолиВРМ = Новый Соответствие;
	
	Если СписокВРМ.Количество() > 0 Тогда
		ТаблицаВРМ = МассивВТаблицуЗначений(СписокВРМ, "ВРМ");
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ТаблицаВРМ", ТаблицаВРМ);
		Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
		Запрос.Текст = "
			|ВЫБРАТЬ
			|	СписокВРМ.ВРМ КАК ВРМ
			|ПОМЕСТИТЬ
			|	ТаблицаВРМ
			|ИЗ
			|	&ТаблицаВРМ КАК СписокВРМ;
			|
			|ВЫБРАТЬ
			|	ВРМ КАК ВРМ,
			|	ВРМ.Роль КАК Роль
			|ИЗ
			|	ТаблицаВРМ";
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			РолиВРМ[Выборка.ВРМ] = Выборка.Роль;
		КонецЦикла;
	КонецЕсли;
	
	Возврат РолиВРМ;
	
КонецФункции // РолиВРМ()

// Получить причину таймаута подготовки Теста
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарий, ссылка на подготавливаемый сценарий
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Строка
//
Функция ТаймаутПодготовки(Сценарий, Тест)
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ПРЕДСТАВЛЕНИЕ(ТЦСценарийЗапуска.Роль) КАК Роль,
	               |	ПРЕДСТАВЛЕНИЕ(ТЦСценарийЗапуска.Клиент) КАК Клиент,
	               |	ПРЕДСТАВЛЕНИЕ(ТЦСценарийЗапуска.Пользователь) КАК Пользователь,
	               |	ПРЕДСТАВЛЕНИЕ(ТЦСценарийЗапуска.Компьютер) КАК Компьютер,
	               |	КОЛИЧЕСТВО(ТЦСценарийЗапуска.Ид) КАК Количество
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
	               |ГДЕ
	               |	ТЦСценарийЗапуска.Запущен <> 2
	               |
	               |СГРУППИРОВАТЬ ПО
	               |	ТЦСценарийЗапуска.Роль,
	               |	ТЦСценарийЗапуска.Клиент,
	               |	ТЦСценарийЗапуска.Пользователь,
	               |	ТЦСценарийЗапуска.Компьютер";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Список = "";
	
	// Сформировать список ВРМ, которые не успели запуститься
	Пока Выборка.Следующий() Цикл
		Список = Список + "
			| - " + Формат(Выборка.Количество, "ЧГ=0") + " x "
			+ Выборка.Роль + " [" + Выборка.Пользователь + "] на "
			+ Выборка.Компьютер + " <" + Выборка.Клиент + ">";
	КонецЦикла;
	
	// Сообщить о не запущенных ВРМ
	Возврат "Следующие ВРМ не удалось подготовить до истечения таймаута подготовки ("
		+ Тест.ТаймаутПодготовки + " с):" + Список;
	
КонецФункции // ТаймаутПодготовки()

// Получить описание таймаута инициализации
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Строка - описание
//
Функция ТаймаутИнициализации(Сценарий, Тест)
	
	Возврат "Не все ВРМ успели инициализироваться до истечения таймаута инициализации (" +
		Тест.ТаймаутИнициализации + " с)";
	
КонецФункции // ТаймаутИнициализации()

// Получить описание таймаута выполнения
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Строка - описание
//
Функция ТаймаутВыполнения(Сценарий, Тест)
	
	Возврат "Не все ВРМ успели выполнить действия до истечения таймаута выполнения (" +
		Тест.ТаймаутВыполнения + " с)";
	
КонецФункции // ТаймаутВыполнения()

// Получить описание таймаута записи результатов
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Строка - описание
//
Функция ТаймаутЗаписиРезультатов(Сценарий, Тест)
	
	Возврат "Не все ВРМ успели записать результаты до истечения таймаута записи результатов (" +
		Тест.ТаймаутЗаписиРезультатов + " с)";
	
КонецФункции // ТаймаутЗаписиРезультатов()

// Получить описание таймаута удаления данных
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Строка - описание
//
Функция ТаймаутУдаленияДанных(Сценарий, Тест)
	
	Возврат "Не все ВРМ успели удалить данные до истечения таймаута удаления данных (" +
		Тест.ТаймаутУдаленияДанных + " с)";
	
КонецФункции // ТаймаутУдаленияДанных()

// Проверить, не отменен ли процесс тестирования (например, пользователем)
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Булево - Истина, тест отменен
//
Функция ТестПрерван(Тест)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Тест", Тест);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Прерван
		|ИЗ
		|	Документ.ТЦТест
		|ГДЕ
		|	Ссылка = &Тест";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Прерван;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции // ТестПрерван()

// Проверить, не завершен ли процесс тестирования (например, пользователем)
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Булево - Истина, тест отменен
//
Функция ТестЗавершен(Тест)
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Тест", Тест);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Завершен
		|ИЗ
		|	Документ.ТЦТест
		|ГДЕ
		|	Ссылка = &Тест";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Завершен;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции // ТестЗавершен()

// Создать контекст выполнения тестовой обработки
//
// Возвращаемое значение:
//  Структура
//    СтатусСообщения - Структура
//      Информация - ПеречислениеСсылка.ТЦСтатусСообщения.Информация
//      Предупреждение - ПеречислениеСсылка.ТЦСтатусСообщения.Предупреждение
//      Ошибка - ПеречислениеСсылка.ТЦСтатусСообщения.Ошибка
//    РезультатВыполнения - Структура
//      Успешно - Перечисление.ТЦРезультатВыполнения.Успешно
//      Предупреждение - Перечисление.ТЦРезультатВыполнения.Предупреждение
//      Ошибка - Перечисление.ТЦРезультатВыполнения.Ошибка
//    Результаты - Соответствие
//      Ключ - Строка, имя показателя производительности
//      Значение - Число, значение показателя производительности
//
Функция СоздатьКонтекстВыполненияОбработки() Экспорт
	
	Статус = Новый Структура;
	Статус.Вставить("Информация", Перечисления.ТЦСтатусСообщения.Информация);
	Статус.Вставить("Предупреждение", Перечисления.ТЦСтатусСообщения.Предупреждение);
	Статус.Вставить("Ошибка", Перечисления.ТЦСтатусСообщения.Ошибка);
	
	Результат = Новый Структура;
	Результат.Вставить("Успешно", Перечисления.ТЦРезультатВыполнения.Успешно);
	Результат.Вставить("Предупреждение", Перечисления.ТЦРезультатВыполнения.Предупреждение);
	Результат.Вставить("Ошибка", Перечисления.ТЦРезультатВыполнения.Ошибка);
	Результат.Вставить("Продолжить", Перечисления.ТЦРезультатВыполнения.Продолжить);
	Результат.Вставить("Неопределено", Перечисления.ТЦРезультатВыполнения.Неопределено);
	
	Контекст = Новый Структура;
	
	Контекст.Вставить("ВозниклоИсключение", Ложь);
	Контекст.Вставить("ТекстИсключенияИлиОшибки");
	Контекст.Вставить("ТекущаяОперация");
	Контекст.Вставить("МассивДействий");
	Контекст.Вставить("КоэффициентИнтенсивности", 1);
	Контекст.Вставить("НачалоТекущегоЗамера");
	Контекст.Вставить("ОкончаниеТекущегоЗамера");
	Контекст.Вставить("ЗавершатьРаботуПослеВыполнения", Ложь);
	Контекст.Вставить("ПоказыватьОшибкиИСообщения", Ложь);
	Контекст.Вставить("СтатусСообщения", Статус);
	Контекст.Вставить("ТекущийРезультатВыполнения");
	Контекст.Вставить("РезультатВыполнения", Результат);
	Контекст.Вставить("Результаты", Новый Соответствие);
	Контекст.Вставить("ВРМ", Новый Структура("Роль, ИмяРоли, Компьютер, Пользователь, Номер, Сценарий"));
	Контекст.Вставить("ФормаВРМ");
	
	Возврат Контекст;
	
КонецФункции // СоздатьКонтекстВыполненияОбработки()

// Продолжить выполнение теста
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
Процедура ПродолжитьТестПослеПаузыВРМ(Тест) Экспорт
	
	ИзменитьТест(Тест, "УстановитьПаузуПослеЗапускаВРМ", Ложь);
	
КонецПроцедуры // ПродолжитьТестПослеПаузыВРМ()

// Завершить работу одного или нескольких ВРМ
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП или Массив (СправочникСсылка.ТЦВП)
//
Процедура ЗавершитьРаботуВРМ(Знач ВРМ) Экспорт
	
	Если ТипЗнч(ВРМ) = Тип("СправочникСсылка.ТЦВП") Тогда
		СписокВРМ = Новый Массив;
		СписокВРМ.Добавить(ВРМ);
	Иначе
		СписокВРМ = ВРМ
	КонецЕсли;
	
	ТаблицаВРМ = МассивВТаблицуЗначений(СписокВРМ, "Ссылка");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ТаблицаВРМ", ТаблицаВРМ);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	ИсходныеВРМ.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ
		|	ТаблицаВРМ
		|ИЗ
		|	&ТаблицаВРМ КАК ИсходныеВРМ
		|ИНДЕКСИРОВАТЬ ПО
		|	ИсходныеВРМ.Ссылка;
		|
		|ВЫБРАТЬ
		|	ТаблицаВРМ.Ссылка КАК ВРМ,
		|	Агенты.Ссылка КАК Агент
		|ИЗ
		|	ТаблицаВРМ ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ТЦАгенты КАК Агенты ПО
		|		ТаблицаВРМ.Ссылка.Клиент.Компьютер = Агенты.Компьютер
		|УПОРЯДОЧИТЬ ПО
		|	Агенты.Ссылка
		|ИТОГИ ПО
		|	Агенты.Ссылка";
	ВыборкаАгентов = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
	Пока ВыборкаАгентов.Следующий() Цикл
		ВыборкаВРМ = ВыборкаАгентов.Выбрать();
		ВыгружаемыеВРМ = Новый Массив;
		
		Пока ВыборкаВРМ.Следующий() Цикл
			Если ВыборкаВРМ.Агент = Null Тогда
				УдалитьВРМ(ВыборкаВРМ.ВРМ);
			Иначе
				ВыгружаемыеВРМ.Добавить(ВыборкаВРМ.ВРМ);
			КонецЕсли;
		КонецЦикла;
		
		ТЦСервер.ОтправитьСообщение(
			ВыборкаАгентов.Агент,,
			Перечисления.ТЦСообщение.ЗавершитьРаботу,
			ВыгружаемыеВРМ);
	КонецЦикла;
	
КонецПроцедуры // ЗавершитьРаботуВРМ()

// Завершить работу одного или нескольких Агентов
//
// Параметры:
//  Агенты - СправочникСсылка.ТЦАгенты или Массив (СправочникСсылка.ТЦАгенты)
//
Процедура ЗавершитьРаботуАгента(Знач Агенты) Экспорт
	
	Если ТипЗнч(Агенты) = Тип("СправочникСсылка.ТЦАгенты") Тогда
		СписокАгентов = Новый Массив;
		СписокАгентов.Добавить(Агенты);
	Иначе
		СписокАгентов = Агенты;
	КонецЕсли;
	
	Для каждого Агент Из СписокАгентов Цикл
		ТЦСервер.ОтправитьСообщение(Агент,, Перечисления.ТЦСообщение.ЗавершитьРаботу);
	КонецЦикла;
	
КонецПроцедуры // ЗавершитьРаботуАгента()

// Проверить, выполняется ли тест
//
// Параметры:
//  Тест - ДокументСсылка.ТЦТест
//
// Возвращаемое значение:
//  Булево - Истина, выполняется
//
Функция ТестВыполняется(ПроверяемыйТест = Неопределено) Экспорт
	
	Если ПроверяемыйТест = Неопределено Тогда
		Тест = ТЦСервер.ТекущийТест();
	Иначе
		Тест = ПроверяемыйТест;
	КонецЕсли;
	
	Если Тест = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Тест", Тест);
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦТест.Менеджер
	               |ИЗ
	               |	Документ.ТЦТест КАК ТЦТест
	               |ГДЕ
	               |	ТЦТест.Ссылка = &Тест
	               |
	               |ДЛЯ ИЗМЕНЕНИЯ
	               |	Документ.ТЦТест";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Попытка
			Ид = Новый УникальныйИдентификатор(Выборка.Менеджер);
		Исключение
			Возврат Ложь;
		КонецПопытки;
		
		Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(Ид);
		
		Если Задание <> Неопределено Тогда
			Если Задание.Состояние = СостояниеФоновогоЗадания.Активно Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // ТестВыполняется()

///////////////////////////////////////////////////////////////////////////////
// ОБМЕН СООБЩЕНИЯМИ

// Отправить сообщение на указанный адрес
//
// Параметры:
//  Адрес - ЛюбаяСсылка, кому предназначается сообщение
//  От - ЛюбаяСсылка, кто отправил сообщение
//  Сообщение - ПеречислениеСсылка
//  Параметры - ХранилищеЗначения, произвольные параметры
//
Процедура ОтправитьСообщение(Адрес,
                             От = Неопределено,
                             Сообщение,
                             Параметры = Неопределено) Экспорт
	
	СообщениеОбъект = Справочники.ТЦОчередьСообщений.СоздатьЭлемент();
	СообщениеОбъект.ОбменДанными.Загрузка = Истина;
	СообщениеОбъект.Адрес = Адрес;
	СообщениеОбъект.Отправитель = От;
	СообщениеОбъект.Сообщение = Сообщение;
	СообщениеОбъект.Параметры = Новый ХранилищеЗначения(Параметры);
	СообщениеОбъект.Записать();
	
КонецПроцедуры // ОтправитьСообщение()

// Отправить сообщение группе адресатов
//
// Параметры:
//  Группа - ТаблицаЗначений с колонкой Ссылка
//  От - ЛюбаяСсылка, кто отправил сообщение
//  Сообщение - ПеречислениеСсылка
//  Параметры - ХранилищеЗначения, произвольные параметры
//
Процедура ОтправитьСообщенияГруппе(Группа,
                                   От = Неопределено,
                                   Сообщение,
                                   Параметры = Неопределено) Экспорт
	
	Для каждого Адрес Из Группа Цикл
		ОтправитьСообщение(Адрес, От, Сообщение, Параметры);
	КонецЦикла;
	
КонецПроцедуры // ОтправитьСообщенияГруппе()

// Получить запрос получения недоставленных сообщений
//
// Параметры:
//  Группа - Массив ссылок на адресаты, доставка которых проверяется
//
// Возвращаемое значение:
//  Запрос
//
Функция ПолучитьЗапросНеДоставленныхСообщений(Группа)
	
	ТаблицаГруппы = МассивВТаблицуЗначений(Группа, "Ссылка");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("Группа", ТаблицаГруппы);
	Запрос.Текст = "ВЫБРАТЬ
	               |	Группа.Ссылка КАК Ссылка
	               |ПОМЕСТИТЬ Адресаты
	               |ИЗ
	               |	&Группа КАК Группа
	               |
	               |ИНДЕКСИРОВАТЬ ПО
	               |	Ссылка";
	Запрос.Выполнить();
		
	Запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
	               |	АдресатыДоставки.Ссылка КАК Ссылка,
	               |	ПРЕДСТАВЛЕНИЕ(АдресатыДоставки.Ссылка) КАК Представление
	               |ИЗ
	               |	Адресаты КАК АдресатыДоставки
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ТЦОчередьСообщений КАК Очередь
	               |		ПО АдресатыДоставки.Ссылка = Очередь.Адрес";
		
	Возврат Запрос;
	
КонецФункции // ПолучитьЗапросНеДоставленныхСообщений()

// Получить сообщение на свой адрес и удалить его при необходимости
//
// Параметры:
//  Адрес - ЛюбаяСсылка, кому предназначается сообщение
//  От - ЛюбаяСсылка, кто отправил сообщение
//  Удалить - Булево, Истина - удалить сообщение, после его получения
//
// Возвращаемое значение:
//  Структура:
//    Сообщение - ПеречислениеСсылка
//    Параметры - ЛюбоеЗначение
//  Неопределено - если сообщений нет
//
Функция ПолучитьСообщение(Адрес, От = Неопределено, Удалить = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Адрес", Адрес);
	ЕстьОтправитель = От <> Неопределено;
	
	Если ЕстьОтправитель Тогда
		Запрос.УстановитьПараметр("Отправитель", От);
	КонецЕсли;
	
	Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	" + ?(Удалить, "Ссылка,", "") + "
		|	Параметры,
		|	Сообщение,
		|	Отправитель
		|ИЗ
		|	Справочник.ТЦОчередьСообщений
		|ГДЕ
		|	Адрес = &Адрес
		|" + ?(ЕстьОтправитель, "И Отправитель = &Отправитель", "");
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Если Удалить Тогда
			
			Объект = Выборка.Ссылка.ПолучитьОбъект();
			
			Если Объект <> Неопределено Тогда
				
				Объект.ОбменДанными.Загрузка = Истина;
				
				Попытка
					Объект.Удалить();
				Исключение
					ТекстОшибки = "Не удалось удалить сообщение (ТЦОчередьСообщений): " + ТЦОбщий.ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке());
					ТЦОбщий.ЗаписатьВЖурнал(ТекстОшибки, , Перечисления.ТЦСтатусСообщения.Предупреждение);
				КонецПопытки;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Результат = Новый Структура;
		Результат.Вставить("Отправитель", Выборка.Отправитель);
		Результат.Вставить("Сообщение", Выборка.Сообщение);
		Результат.Вставить("Параметры", Выборка.Параметры.Получить());
		
		Возврат Результат;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПолучитьСообщение()

// УдалитьВсе сообщения адресата
//
// Параметры:
//  Адрес - ЛюбаяСсылка, адресат удаляемых сообщений
//
Процедура УдалитьСообщенияАдресата(Адрес) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Адрес", Адрес);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	Справочник.ТЦОчередьСообщений
		|ГДЕ
		|	Адрес = &Адрес";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ОбменДанными.Загрузка = Истина;
		
		Попытка
			Объект.Удалить();
		Исключение
			ТекстОшибки = "Не удалось удалить сообщение (ТЦОчередьСообщений): " + ТЦОбщий.ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке());
			ТЦОбщий.ЗаписатьВЖурнал(ТекстОшибки, , Перечисления.ТЦСтатусСообщения.Предупреждение);
		КонецПопытки;
			
	КонецЦикла;
	
КонецПроцедуры // УдалитьСообщенияАдресата()

// Запаковать сообщение для локальной передачи
//
// Параметры:
//  Отправитель - Строка, уникальный идентификатор отправителя
//  Сообщение - Перечисление.ТЦСообщение
//  Параметры - Произвольный
//
// Возвращаемое значение:
//  Строка - Запакованное сообщение
//
Функция ЗапаковатьЛокальноеСообщение(Отправитель,
                                     Сообщение,
                                     Параметры = Неопределено) Экспорт
	
	Пакет = Новый Структура;
	Пакет.Вставить("Отправитель", Отправитель);
	Пакет.Вставить("Сообщение", Сообщение);
	Пакет.Вставить("Параметры", Параметры);
	Возврат ЗначениеВСтрокуВнутр(Пакет);
	
КонецФункции // ЗапаковатьЛокальноеСообщение()

// Распаковать локальное сообщение
//
// Параметры:
//  Сообщение - Строка, Запакованное сообщение
//
// Возвращаемое значение:
//  Структура:
//   Отправитель - Строка, уникальный идентификатор отправителя
//   Сообщение - Перечисление.ТЦСообщение
//   Параметры - Произвольный
//
Функция РаспаковатьЛокальноеСообщение(Сообщение) Экспорт
	
	Возврат ЗначениеИзСтрокиВнутр(Сообщение);
	
КонецФункции // РаспаковатьЛокальноеСообщение()

// Сериализовать значение в XML и вернуть в виде строки
//
// Параметры:
//  Значение - Произвольный, преобразуемое значение
//
// Возвращаемое значение:
//  Строка - значение, сериализованное в XML
//
Функция Сериализовать(Значение) Экспорт
	
	Возврат ЗначениеВСтрокуВнутр(Значение);
	
КонецФункции // Сериализовать()

// Восстановить значение из XML представления
//
// Параметры:
//  Значение - Строка, XML представление значения
//
// Возвращаемое значение:
//  Произвольное, десериализованное значение
//
Функция Десериализовать(Значение) Экспорт
	
	Возврат ЗначениеИзСтрокиВнутр(Значение);
	
КонецФункции // Десериализовать()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ОБЪЕКТАМИ

// Найти компьютер и при необходимости создать новый
//
// Параметры:
//  ИмяКомпьютера - Строка, наименование компьютера
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦКомпьютер
//
Функция НайтиКомпьютер(ИмяКомпьютера) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяКомпьютера", ИмяКомпьютера);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	Справочник.ТЦКомпьютеры
		|ГДЕ
		|	Наименование = &ИмяКомпьютера";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Ссылка;
	Иначе
		НовыйКомпьютер = Справочники.ТЦКомпьютеры.СоздатьЭлемент();
		НовыйКомпьютер.ОбменДанными.Загрузка = Истина;
		НовыйКомпьютер.Наименование = ИмяКомпьютера;
		НовыйКомпьютер.Записать();
		Возврат НовыйКомпьютер.Ссылка;
	КонецЕсли;
	
КонецФункции // НайтиКомпьютер()

// Преобразовать ссылку в строку
//
// Параметры:
//  Ссылка - ЛюбаяСсылка
//
// Возвращаемое значение:
//  Строка, ссылка в виде GUID
//
Функция СсылкуВСтроку(Ссылка) Экспорт
	
	Возврат Строка(Ссылка.УникальныйИдентификатор());
	
КонецФункции // СсылкуВСтроку()

// Получить значения реквизитов объекта по ссылке, в виде структуры
//
// Параметры:
//  Ссылка - ЛюбаяСсылка
//
// Возвращаемое значение:
//  Структура - Имена полей и значения, соответствуют реквизитам объекта
//
Функция РеквизитыОбъектаПоСсылке(Ссылка) Экспорт
	
	Объект = Ссылка.ПолучитьОбъект();
	Реквизиты = Объект.Метаданные().Реквизиты;
	Значения = Новый Структура;
	
	Для каждого Реквизит Из Реквизиты Цикл
		Имя = Реквизит.Имя;
		Значения.Вставить(Имя, Объект[Имя]);
	КонецЦикла;
	
	Возврат Значения;
	
КонецФункции // РеквизитыОбъектаПоСсылке()

// Получить параметры клиента из ссылки на элемент справочника ТЦКлиенты
//
// Параметры:
//  Клиент - СправочникСсылка.ТЦКлиенты
//
// Возвращаемое значение:
//  Структура
//   Компьютер - Строка
//   СтрокаЗапуска - Строка
//
Функция ПараметрыКлиента(Клиент) Экспорт
	
	Параметры = РеквизитыОбъектаПоСсылке(Клиент);
	Параметры.Компьютер = Параметры.Компьютер.Наименование;
	
	Возврат Параметры;
	
КонецФункции // ПараметрыКлиента()

// Получить параметры Роли по ссылке
//
// Параметры:
//  Роль - СправочникСсылка.ТЦРоли
//
// Возвращаемое значение:
//  Структура
//
Функция ПараметрыРоли(Роль) Экспорт
	
	Параметры = РеквизитыОбъектаПоСсылке(Роль);
	
	Возврат Параметры;
	
КонецФункции // ПараметрыРоли()

// Получить параметры ВРМ
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//
// Возвращаемое значение:
//  Структура
//   Клиент - СправочникСсылка.ТЦКлиенты
//   Пользователь - СправочникСсылка.ТЦПользователи
//
Функция ПараметрыВРМ(ВРМ) Экспорт
	
	Возврат РеквизитыОбъектаПоСсылке(ВРМ);
	
КонецФункции // ПараметрыВРМ()

// Дополнить строку запуска параметрами аутентификации
//
// Параметры:
//  Клиент - СправочникСсылка.ТЦКлиенты
//  Пользователь - СправочникСсылка.ТЦПользователи
//  Ид - Строка - Уникальный идентификатор нового ВРМ
//
// Возвращаемое значение:
//  Строка
//
Функция ПолнаяСтрокаЗапуска(Клиент, Пользователь, Ид, ЭтоLinux) Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		СтрокаЗапуска = Клиент.СтрокаЗапуска;
		ПараметрыЗапуска
			= "TCVW;"
			+ Клиент.УникальныйИдентификатор() + ";"
			+ Пользователь.УникальныйИдентификатор() + ";"
			+ Ид;
			
		Если Не ПустаяСтрока(Клиент.ДополнительныеПараметрыПрикладногоРешения) Тогда
			ПараметрыЗапуска = ПараметрыЗапуска + ";" + Клиент.ДополнительныеПараметрыПрикладногоРешения;
		КонецЕсли;
		
		СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(
			Клиент.ТипКлиента, СтрокаЗапуска, "C", ПараметрыЗапуска, ЭтоLinux);
			
		ЭтоВеб = Клиент.ТипКлиента = Перечисления.ТЦТипКлиента.Веб Или
			Клиент.ТипКлиента = Перечисления.ТЦТипКлиента.ТонкийВеб;
			
		Если Не ЭтоВеб Тогда
			Соединение = СтрокаСоединенияИнформационнойБазы();
			СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(Клиент.ТипКлиента, СтрокаЗапуска, "IBConnectionString ", Соединение, ЭтоLinux);
		КонецЕсли;
		
		Если Пользователь.ТипАутентификации = Перечисления.ТЦТипАутентификации.Аутентификация1С Тогда
			СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(
				Клиент.ТипКлиента, СтрокаЗапуска, "WA-",, ЭтоLinux);
			
			СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(
				Клиент.ТипКлиента, СтрокаЗапуска, "N", Пользователь.Имя, ЭтоLinux);
				
			Если ЗначениеЗаполнено(Пользователь.Пароль) Тогда
				СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(
					Клиент.ТипКлиента, СтрокаЗапуска, "P", Пользователь.Пароль, ЭтоLinux);
			КонецЕсли;
		КонецЕсли;
		
		// Ключи для запуска в разделённом режиме
		Стр = "";
		РазделениеДанных = ТЦПользовательВПользовательИБ(Пользователь).РазделениеДанных;
		НеИспользовать = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.НеИспользовать;
		Для Каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
			Если ОбщийРеквизит.РазделениеДанных <> НеИспользовать Тогда
			ИмяОбщегоРеквизита = ОбщийРеквизит.Имя;
			Если РазделениеДанных.Свойство(ИмяОбщегоРеквизита) Тогда
				Стр = ТЦОбщий.ДобавитьРазделитель(
					Стр,
					РазделениеДанных[ИмяОбщегоРеквизита],
					Истина
				);
			Иначе
				Стр = ТЦОбщий.ДобавитьРазделитель(
					Стр,
					"",
					Ложь
				);
			КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ПустаяСтрока(Стр) Тогда
			СтрокаЗапуска = ТЦОбщий.ДобавитьПараметрКлиента(
				Клиент.ТипКлиента, СтрокаЗапуска, "Z", Стр, ЭтоLinux);
		КонецЕсли;
		
		Возврат СтрокаЗапуска;
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции // ПолнаяСтрокаЗапуска()

// Сохранить значения реквизитов обработки в хранилище значения
//
// Параметры:
//  Обработка - ОбработкаОбъект, исходная обработка
//
// Возвращаемое значение:
//  ХранилищеЗначения - результат экспорта данных
//
Функция СохранитьРеквизитыОбработки(Обработка) Экспорт
	
	Значения = Новый Соответствие;
	МетаданныеОбработки = Обработка.Метаданные();
	Реквизиты = МетаданныеОбработки.Реквизиты;
	ТабличныеЧасти = МетаданныеОбработки.ТабличныеЧасти;
	
	Для каждого Реквизит Из Реквизиты Цикл
		Имя = Реквизит.Имя;
		Значения[Имя] = Обработка[Имя];
	КонецЦикла;
	
	ТЦТабличныеЧасти = Новый Соответствие;
	Значения["ТЦТабличныеЧасти"] = ТЦТабличныеЧасти;
	
	Для каждого ТЧ Из ТабличныеЧасти Цикл
		Имя = ТЧ.Имя;
		ТЦТабличныеЧасти[Имя] = Обработка[Имя].Выгрузить();
	КонецЦикла;
	
	Возврат Новый ХранилищеЗначения(Значения, Новый СжатиеДанных(9));
	
КонецФункции // СохранитьРеквизитыОбработки()

// Загрузить значения реквизитов обработки из ранее сохраненного, при помощи
// СохранитьРеквизитыОбработки(), ХранилищаЗначения
//
// Параметры:
//  Обработка - ОбработкаОбъект, обработка в которую загружаются данные
//  АрхивЗначений - ХранилищеЗначения, данные для загрузки
//
Процедура ЗагрузитьРеквизитыОбработки(Обработка, АрхивЗначений) Экспорт
	
	Значения = АрхивЗначений.Получить();
	
	Если Значения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеОбработки = Обработка.Метаданные();
	Реквизиты = МетаданныеОбработки.Реквизиты;
	ТабличныеЧасти = МетаданныеОбработки.ТабличныеЧасти;
	
	Для каждого Реквизит Из Реквизиты Цикл
		Имя = Реквизит.Имя;
		Обработка[Имя] = Значения[Имя];
	КонецЦикла;
	
	ТЦТабличныеЧасти = Значения["ТЦТабличныеЧасти"];
	
	Для каждого ТЧ Из ТабличныеЧасти Цикл
		Имя = ТЧ.Имя;
		Обработка[Имя].Загрузить(ТЦТабличныеЧасти[Имя]);
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьРеквизитыОбработки()

// Получить описание ВРМ
//
// Возвращаемое значение:
//  Соостветствие
//    Ключ - ВРМ
//    Значение - Структура
//      Роль - Строка, имя роли
//      Компьютер - Строка, имя компьютера
//      Пользователь - Строка, имя пользователя
//
Функция ОписаниеВРМ()
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка КАК ВРМ,
		|	Роль КАК Роль,
		|	Роль.Наименование КАК ИмяРоли,
		|	Клиент.Компьютер.Наименование КАК Компьютер,
		|	Пользователь.Наименование КАК Пользователь
		|ИЗ
		|	Справочник.ТЦВП";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Описание = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		Значения = Новый Структура;
		Значения.Вставить("Роль", Выборка.Роль);
		Значения.Вставить("ИмяРоли", Выборка.ИмяРоли);
		Значения.Вставить("Компьютер", Выборка.Компьютер);
		Значения.Вставить("Пользователь", Выборка.Пользователь);
		Описание.Вставить(Выборка.ВРМ, Значения);
	КонецЦикла;
	
	Возврат Описание;
	
КонецФункции // ОписаниеВРМ()

// Подключить обработку
//
// Параметры:
//  Путь - путь к внешней обработке
//
Функция ПодключитьОбработку(Путь) Экспорт
	
	Возврат ВнешниеОбработки.Подключить(Путь,, Ложь);
	
КонецФункции // ПодключитьОбработку()

// Определить, содержит ли хранилище значения - данные
//
// Параметры:
//  Хранилище - ХранилищеЗначения
//
// Возвращаемое значение:
//  Булево - Истина, заполнено
//
Функция ХранилищеЗаполнено(Хранилище) Экспорт
	
	Возврат Хранилище.Получить() <> Неопределено;
	
КонецФункции // ХранилищеЗаполнено()

// Получить список тестовых обработок, доступных в дереве метаданных
//
// Возвращаемое значение:
//  Массив - строки, указывающие на имена тестовых обработок
//
Функция СписокТестовыхОбработок() Экспорт
	
	ТестовыеОбработки = Новый Массив;
	
	Для каждого Обработка Из Метаданные.Обработки Цикл
		ОсновнаяФорма = Обработка.ОсновнаяФорма;
		
		Если ОсновнаяФорма <> Неопределено Тогда
			Если ОсновнаяФорма.Имя = "ТЦФорма" Тогда
				Описание = Новый Структура;
				Описание.Вставить("Имя", Обработка.Имя);
				Описание.Вставить("Синоним", Обработка.Синоним);
				ТестовыеОбработки.Добавить(Описание);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТестовыеОбработки;
	
КонецФункции // СписокТестовыхОбработок()

// Проверка заполнения реквизита формы
//
// Параметры:
//  УсловиеОтказа - Булево
//  ИмяРеквизита - Строка
//  ТекстСообщения - Строка
//
// Возвращаемое значение:
//  Булево - Истина, отказ
//
Функция РеквизитЗаполнен(УсловиеОтказа, ИмяРеквизита, ТекстСообщения) Экспорт
	
	Если УсловиеОтказа Тогда
		Сообщение = Новый СообщениеПользователю();
		Сообщение.Текст = ТекстСообщения;
		Сообщение.Поле = ИмяРеквизита;
		Сообщение.Сообщить();
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции // РеквизитЗаполнен()

// Получить кеш перечислений
//
// Возвращаемое значение:
//  Структура
//
Функция ПолучитьПеречисления() Экспорт
	
	Перем Ссылка;
	ВсеПеречисления = Новый Структура;
	
	Для каждого Перечисление Из Метаданные.Перечисления Цикл
		Значения = Новый Структура;
		ВсеПеречисления.Вставить(Перечисление.Имя, Значения);
		
		Для каждого Значение Из Перечисление.ЗначенияПеречисления Цикл
			Выполнить "Ссылка = Перечисления." + Перечисление.Имя + "." + Значение.Имя;
			Значения.Вставить(Значение.Имя, Ссылка);
		КонецЦикла;
	КонецЦикла;
	
	Возврат ВсеПеречисления;
	
КонецФункции // ПолучитьПеречисления()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С АГЕНТОМ

// Проверить, запущен ли агент на указанном компьютере
//
// Параметры:
//  ИмяКомпьютера - Строка, наименование проверяемого компьютера
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦАгенты - ссылка на запущенный агент,
//  Неопределено - если агент не запущен
//
Функция АгентЗапущен(ИмяКомпьютера, НомерСессии) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяКомпьютера", ИмяКомпьютера);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	Ссылка КАК АктивныйАгент
		|ИЗ
		|	Справочник.ТЦАгенты КАК Агент
		|ГДЕ
		|	Компьютер.Наименование = &ИмяКомпьютера И
		|	НомерСессии = &НомерСессии";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.АктивныйАгент;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // АгентЗапущен()

// Проверить, запущены ли Агенты
//
// Параметры:
//  Агенты - Массив (СправочникСсылка.ТЦАгенты), проверяемые агенты
//
// Возвращаемое значение:
//  Массив (СправочникСсылка.ТЦАгенты) - Агенты, которые еще запущены
//
Функция КлиентыЗапущены(Знач Клиенты) Экспорт
	
	Запущенные = Новый Массив;
	
	Если Клиенты.Количество() = 0 Тогда
		Возврат Запущенные;
	КонецЕсли;
	
	ИмяТипа = Клиенты[0].Метаданные().Имя;
	
	ТаблицаКлиентов = МассивВТаблицуЗначений(Клиенты, "Ссылка");
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ТаблицаКлиенты", ТаблицаКлиентов);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Клиенты.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ
		|	ТаблицаКлиентов
		|ИЗ
		|	&ТаблицаКлиенты КАК Клиенты
		|ИНДЕКСИРОВАТЬ ПО
		|	Ссылка;
		|
		|ВЫБРАТЬ
		|	Запущенные.Ссылка КАК ССылка
		|ИЗ
		|	ТаблицаКлиентов КАК Запущенные ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник." + ИмяТипа + " КАК ВсеКлиенты ПО
		|		Запущенные.Ссылка = ВсеКлиенты.Ссылка";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Запущенные.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
	Возврат Запущенные;
	
КонецФункции // КлиентыЗапущены()

// Удалить записи клиентов
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//
Процедура УдалитьКлиентов(Клиенты) Экспорт
	
	Для каждого Клиент Из Клиенты Цикл
		
		Попытка
			
			КлиентОбъект = Клиент.ПолучитьОбъект();
			
			Если КлиентОбъект <> Неопределено Тогда
				КлиентОбъект.ОбменДанными.Загрузка = Истина;
				КлиентОбъект.Удалить();
			КонецЕсли;
			
		Исключение
			// Может возникнуть исключение при конкурентной выгрузке ВРМ.
			// Исключение в этой секции не является критичным с точки зрения теста и тестового механизма.
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьКлиентов()

// Получить порт Агента
//
// Параметры:
//  НомерСессии - СправочникСсылка.ТЦВРМ, ссылка на ВРМ
//
// Возвращаемое значение:
//  Число - номер порта ВРМ
//
Функция ПолучитьПортАгента(ИмяКомпьютера, НомерСессии) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦАгенты.Порт
	               |ИЗ
	               |	Справочник.ТЦАгенты КАК ТЦАгенты
	               |ГДЕ
	               |	ТЦАгенты.НомерСессии = &НомерСессии
	               |	И ТЦАгенты.Компьютер.Наименование = &ИмяКомпьютера";
	
	Запрос.УстановитьПараметр("ИмяКомпьютера", ИмяКомпьютера);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Следующий() Тогда
		ПортАгента = Выборка.Порт;
	Иначе
		ВызватьИсключение "Не удалось определить порт агента!";
	КонецЕсли;
	
	Возврат ПортАгента;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ВРМ

// Получить порт ВРМ
//
// Параметры:
//  ВРМСсылка - СправочникСсылка.ТЦВРМ, ссылка на ВРМ
//
// Возвращаемое значение:
//  Число - номер порта ВРМ
//
Функция ЛокальныйПортВРМ(ВРМСсылка) Экспорт
	
	ПортВРМ = 0;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Порт
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |ГДЕ
	               |	ТЦВП.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", ВРМСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Следующий() Тогда
		ПортВРМ = Выборка.Порт;
	КонецЕсли;
	
	Возврат ПортВРМ;
	
КонецФункции // ЛокальныйПортВРМ()

// Получить список запущенных ВРМ
//
// Возвращаемое значение:
//  Массив - ссылки на элементы справочника ТЦВП
//
Функция ЗапущенныеВРМ(ИмяКомпьютера, НомерСессии, ВРМЗапущенныеПослеТаймаута = Неопределено, ЗапущенныеВРМ = Неопределено) Экспорт
	
	Компьютер = НайтиКомпьютер(ИмяКомпьютера);
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", Компьютер);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.УстановитьПараметр("ЗапущенныеВРМ", ЗапущенныеВРМ);
	Запрос.УстановитьПараметр("ВРМЗапущенныеПослеТаймаута", ВРМЗапущенныеПослеТаймаута);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Ссылка
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |ГДЕ
	               |	ТЦВП.Клиент.Компьютер = &Компьютер
	               |	И ТЦВП.НомерСессии = &НомерСессии
	               |	И ТЦВП.Состояние <> ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Выгрузка)
	               |	И НЕ ТЦВП.Ссылка В (&ВРМЗапущенныеПослеТаймаута)";
				   
	Если ЗапущенныеВРМ <> Неопределено Тогда				   
		Запрос.Текст = Запрос.Текст + "
					|	И ТЦВП.Ссылка В (&ЗапущенныеВРМ)";
	КонецЕсли;
				   
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // ЗапущенныеВРМ()

// Получить список запущенных ВРМ за исключением ВРМ в резерве
//
// Возвращаемое значение:
//  Массив - адреса запущенных ВРМ
//
Функция ЗапущенныеВРМБезРезерва(ИмяКомпьютера, НомерСессии, ВРМЗапущенныеПослеТаймаута = Неопределено, ЗапущенныеВРМ = Неопределено) Экспорт
	
	Компьютер = НайтиКомпьютер(ИмяКомпьютера);
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", Компьютер);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.УстановитьПараметр("ЗапущенныеВРМ", ЗапущенныеВРМ);
	Запрос.УстановитьПараметр("ВРМЗапущенныеПослеТаймаута", ВРМЗапущенныеПослеТаймаута);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Ссылка
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |ГДЕ
	               |	ТЦВП.Клиент.Компьютер = &Компьютер
	               |	И ТЦВП.НомерСессии = &НомерСессии
	               |	И ТЦВП.Состояние <> ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Выгрузка)
	               |	И ТЦВП.Состояние <> ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Резерв)
	               |	И НЕ ТЦВП.Ссылка В (&ВРМЗапущенныеПослеТаймаута)";
				   
	Если ЗапущенныеВРМ <> Неопределено Тогда				   
		Запрос.Текст = Запрос.Текст + "
					|	И ТЦВП.Ссылка В (&ЗапущенныеВРМ)";
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // ЗапущенныеВРМ()

// Получить список активных ВРМ
//
// Возвращаемое значение:
//  Массив - адреса запущенных ВРМ
//
Функция ПодготавливающиесяВРМ(ИмяКомпьютера, НомерСессии) Экспорт
	
	Компьютер = НайтиКомпьютер(ИмяКомпьютера);
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", Компьютер);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	Справочник.ТЦВП
		|ГДЕ
		|	Клиент.Компьютер = &Компьютер И
		|	НомерСессии = &НомерСессии И
		|	Состояние = ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Подготовка)";
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // ПодготавливающиесяВРМ()

// Деактивировать все ВРМ
//
Процедура ДеактивироватьВРМ(Компьютер = Неопределено, НомерСессии = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Если Компьютер <> Неопределено Тогда
		КомпьютерСсылка = НайтиКомпьютер(Компьютер);
		Запрос.УстановитьПараметр("Компьютер", КомпьютерСсылка);
	КонецЕсли;
	
	Если НомерСессии <> Неопределено Тогда
		Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	КонецЕсли;
	
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка КАК ВРМ
		|ИЗ
		|	Справочник.ТЦВП" + ?(Компьютер = Неопределено, "", "
		|ГДЕ
		|	Клиент.Компьютер = &Компьютер") + ?(НомерСессии = Неопределено, "", " И
		|	НомерСессии = &НомерСессии");
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		НачатьТранзакцию();
		ВРМОбъект = Выборка.ВРМ.ПолучитьОбъект();
		ЗафиксироватьТранзакцию();
		ВРМОбъект.Состояние = Перечисления.ТЦСостояние.ПустаяСсылка();
		ВРМОбъект.Роль = Справочники.ТЦРоли.ПустаяСсылка();
		ВРМОбъект.ОбменДанными.Загрузка = Истина;
		ВРМОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры // ДеактивироватьВРМ()

// Активировать ВРМ
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//
Процедура АктивироватьВРМ(ВРМ) Экспорт
	
	НачатьТранзакцию();
	ВРМОбъект = ВРМ.ПолучитьОбъект();
	ЗафиксироватьТранзакцию();
	ВРМОбъект.Роль = Справочники.ТЦРоли.ПустаяСсылка();
	ВРМОбъект.Состояние = Перечисления.ТЦСостояние.Неактивен;
	ВРМОбъект.ОбменДанными.Загрузка = Истина;
	ВРМОбъект.Записать();
	
КонецПроцедуры // АктивироватьВРМ()

// Установить статус ВРМ
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//  Состояние - ПеречислениеСсылка.ТЦСостояние
//	ЭтапЗавершен - Булево
//
Процедура УстановитьСостояниеВРМ(ВРМ, Состояние, ЭтапЗавершен = Ложь) Экспорт
	
	НачатьТранзакцию();
	
	Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.ТЦВП");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", ВРМ);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
	КонецЕсли;
	
	ВРМОбъект = ВРМ.ПолучитьОбъект();
	Если ВРМОбъект <> Неопределено Тогда
		ВРМОбъект.Состояние = Состояние;
		ВРМОбъект.ЭтапЗавершен = ЭтапЗавершен;
		ВРМОбъект.ОбменДанными.Загрузка = Истина;
		ВРМОбъект.Записать();
	КонецЕсли;
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры

// Пометить ВРМ, как выгружаемое
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//
Процедура ВыгрузитьВРМ(ВРМ) Экспорт
	
	ВРМОбъект = ВРМ.ПолучитьОбъект();
	
	Если ВРМОбъект = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		ВРМОбъект.Роль = Справочники.ТЦРоли.ПустаяСсылка();
		ВРМОбъект.Состояние = Перечисления.ТЦСостояние.Выгрузка;
		ВРМОбъект.ОбменДанными.Загрузка = Истина;
		ВРМОбъект.Записать();
	Исключение
		// Может возникнуть исключение при конкурентной выгрузке ВРМ.
		// Исключение в этой секции не является критичным с точки зрения теста и тестового механизма.
	КонецПопытки;
	
КонецПроцедуры // ВыгрузитьВРМ()

// Загрузить сценарии для ВРМ
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии
//  Компьютер - Строка
// 
//
//
Процедура ЗагрузитьВРМ(Компьютер, НомерСессии, ПродолжающиеРаботуВРМ) Экспорт
	
	КомпьютерСсылка = НайтиКомпьютер(Компьютер);
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", КомпьютерСсылка);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.УстановитьПараметр("ПродолжающиеРаботуВРМ", ПродолжающиеРаботуВРМ);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Ссылка КАК ВРМ,
	               |	ТЦСценарийЗапуска.Клиент КАК Клиент,
	               |	ТЦСценарийЗапуска.Клон КАК Клон,
	               |	ТЦСценарийЗапуска.НомерСессии КАК НомерСессии,
	               |	ТЦСценарийЗапуска.Пользователь КАК Пользователь,
	               |	ТЦСценарийЗапуска.Номер КАК Номер,
	               |	ТЦСценарийЗапуска.Роль КАК Роль,
	               |	ТЦСценарийЗапуска.Состояние КАК Состояние,
	               |	ТЦСценарийЗапуска.ПродолжатьРаботуМеждуИтерациями КАК ПродолжатьРаботуМеждуИтерациями
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
	               |		ПО ТЦВП.Компьютер = ТЦСценарийЗапуска.Компьютер
	               |			И ТЦВП.НомерСессии = ТЦСценарийЗапуска.НомерСессии
	               |			И ТЦВП.Клиент = ТЦСценарийЗапуска.Клиент
	               |			И ТЦВП.Пользователь = ТЦСценарийЗапуска.Пользователь
	               |			И ТЦВП.Клон = ТЦСценарийЗапуска.Клон
	               |ГДЕ
	               |	ТЦСценарийЗапуска.Компьютер = &Компьютер
	               |	И ТЦСценарийЗапуска.НомерСессии = &НомерСессии
	               |	И ТЦВП.НомерСессии = &НомерСессии
	               |	И ТЦВП.Компьютер = &Компьютер
	               |	И ТЦВП.Состояние <> ЗНАЧЕНИЕ(Перечисление.ТЦСостояние.Выгрузка)
	               |	И НЕ ТЦВП.Ссылка В (&ПродолжающиеРаботуВРМ)
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ТЦСценарийЗапуска.Компьютер,
	               |	ТЦСценарийЗапуска.Роль,
	               |	ТЦСценарийЗапуска.Клиент,
	               |	ТЦСценарийЗапуска.Пользователь,
	               |	ТЦСценарийЗапуска.Клон";
				   
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			ОбъектВРМ = Выборка.ВРМ.ПолучитьОбъект();
			ОбъектВРМ.Роль = Выборка.Роль;
			ОбъектВРМ.ПродолжатьРаботуМеждуИтерациями = Выборка.ПродолжатьРаботуМеждуИтерациями;
				
			Если Выборка.Состояние <> Перечисления.ТЦСостояние.Резерв Тогда
				ОбъектВРМ.Состояние = Перечисления.ТЦСостояние.Подготовка;
			Иначе
				ОбъектВРМ.Состояние = Перечисления.ТЦСостояние.Резерв;
			КонецЕсли;
				
			ОбъектВРМ.ОбменДанными.Загрузка = Истина;
			ОбъектВРМ.Записать();
				
		КонецЦикла;
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ЗагрузитьВРМ()

// Посадить виртуального пользователя на виртуальное рабочее место
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВРМ
//
Процедура ПодключитьВПкВРМ(ВРМ) Экспорт
	
	НачатьТранзакцию();
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВРМ", ВРМ);
	Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	Ссылка
		|ИЗ
		|	Справочник.ТЦВП
		|ГДЕ
		|	ВРМ = ЗНАЧЕНИЕ(Справочник.ТЦВРМ.ПустаяСсылка) И
		|	(ГруппаВП.Компьютер, ГруппаВП.Пользователь) В
		|	(
		|		ВЫБРАТЬ
		|			Компьютер,
		|			Пользователь
		|		ИЗ
		|			Справочник.ТЦВРМ
		|		ГДЕ
		|			Ссылка = &ВРМ
		|	)
		|ДЛЯ ИЗМЕНЕНИЯ
		|	Справочник.ТЦВП";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		ВП = Выборка.Ссылка.ПолучитьОбъект();
		ВП.ВРМ = ВРМ;
		ВП.ОбменДанными.Загрузка = Истина;
		ВП.Записать();
	КонецЕсли;
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ПодключитьВПкВРМ()

// Получить ВРМ, которые не отвечают на запросы
//
// Параметры:
//  ИмяКомпьютера - Строка
//  ОтветившиеВРМ - Массив ссылок на не отвечающие ВРМ
//
Функция НерабочиеВРМ(ИмяКомпьютера, НомерСессии, ОтветившиеВРМ) Экспорт
	
	Компьютер = НайтиКомпьютер(ИмяКомпьютера);
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Компьютер", Компьютер);
	Запрос.УстановитьПараметр("ОтветившиеВРМ", ОтветившиеВРМ);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	Ссылка
		|ИЗ
		|	Справочник.ТЦВП
		|ГДЕ
		|	Клиент.Компьютер = &Компьютер И
		|	НомерСессии = &НомерСессии И
		|	НЕ Ссылка В (&ОтветившиеВРМ)";
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции // НерабочиеВРМ()

// Получить первые N незапущенных ВРМ, готовых к запуску
//
// Параметры:
//  ИмяКомпьютера - Строка, имя компьютера на котором будут запускаться ВРМ
//  НомерСессии - Число, номер сессии в которой будут запускаться ВРМ
//  Количество - Число, количество запускаемых ВРМ
// Возвращаемое значение:
//  Массив - ВРМ, которые необходимо запустить
//
Функция НеЗапущенныеВРМ(ИмяКомпьютера, НомерСессии, Количество) Экспорт
	
	Компьютер = НайтиКомпьютер(ИмяКомпьютера);
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос.УстановитьПараметр("Компьютер", Компьютер);
	Запрос.УстановитьПараметр("НомерСессии", НомерСессии);
	
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ " + Формат(Количество, "ЧГ=0") + "
	               |	ТЦСценарийЗапуска.Клиент КАК Клиент,
	               |	ТЦСценарийЗапуска.Пользователь КАК Пользователь,
	               |	ТЦСценарийЗапуска.Клон КАК Клон,
	               |	ТЦСценарийЗапуска.Номер КАК Номер,
	               |	ТЦСценарийЗапуска.Состояние КАК Состояние,
	               |	ТЦСценарийЗапуска.Ид КАК Запуск
	               |ПОМЕСТИТЬ ГотовыеКЗапуску
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
	               |ГДЕ
	               |	ТЦСценарийЗапуска.Компьютер = &Компьютер
	               |	И ТЦСценарийЗапуска.НомерСессии = &НомерСессии
	               |	И ТЦСценарийЗапуска.Запущен = 1
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	КОЛИЧЕСТВО(ТЦСценарийЗапуска.Ид) КАК КоличествоНеготовыхКЗапуску
	               |ПОМЕСТИТЬ НеготовыеКЗапуску
	               |ИЗ
	               |	РегистрСведений.ТЦСценарийЗапуска КАК ТЦСценарийЗапуска
	               |ГДЕ
	               |	ТЦСценарийЗапуска.Компьютер = &Компьютер
	               |	И ТЦСценарийЗапуска.НомерСессии = &НомерСессии
	               |	И ТЦСценарийЗапуска.Запущен = 0";
	
	РезультатЗапроса = Запрос.Выполнить();
	ГотовыеКЗапуску = Запрос.МенеджерВременныхТаблиц.Таблицы.Найти("ГотовыеКЗапуску");
	
	ВозвращаемыйРезультат = Новый Структура;
	ВозвращаемыйРезультат.Вставить("ГотовыеКЗапуску", ТаблицуЗначенийВМассивСтруктур(ГотовыеКЗапуску.ПолучитьДанные().Выгрузить()) );
	
	НеготовыеКЗапуску = Запрос.МенеджерВременныхТаблиц.Таблицы.Найти("НеготовыеКЗапуску");
	Выборка = НеготовыеКЗапуску.ПолучитьДанные().Выбрать();
	Выборка.Следующий();
	
	ВозвращаемыйРезультат.Вставить("КоличествоНеготовыхКЗапуску", Выборка.КоличествоНеготовыхКЗапуску );
	
	Возврат ВозвращаемыйРезультат;
	
КонецФункции // НеЗапущенныеВРМ()

// Отметить, что запуск ВРМ выполнен успешно
//
// Параметры:
//  Запуск - значение измерения Ид из регистра сведений ТЦСценарийЗапуска
//
Процедура ОтметитьЗапускВыполнен(Запуск) Экспорт
	
	СтрокиСценарияЗапуска = РегистрыСведений.ТЦСценарийЗапуска.СоздатьНаборЗаписей();
	СтрокиСценарияЗапуска.Отбор.Ид.Установить(Запуск);
	СтрокиСценарияЗапуска.Прочитать();
	Если СтрокиСценарияЗапуска.Количество() > 0 Тогда
		СтрокиСценарияЗапуска[0].Запущен = 2;
		СтрокиСценарияЗапуска.ОбменДанными.Загрузка = Истина;
		СтрокиСценарияЗапуска.Записать();
	КонецЕсли;
	
КонецПроцедуры // ОтметитьЗапускВыполнен()

// Отметить, что запуск ВРМ готово к запуску
//
// Параметры:
//  Запуск - значение измерения Ид из регистра сведений ТЦСценарийЗапуска
//
Процедура ОтметитьГотовоКЗапуску(Запуск)
	
	СтрокиСценарияЗапуска = РегистрыСведений.ТЦСценарийЗапуска.СоздатьНаборЗаписей();
	СтрокиСценарияЗапуска.Отбор.Ид.Установить(Запуск);
	СтрокиСценарияЗапуска.Прочитать();
	Если СтрокиСценарияЗапуска.Количество() > 0 Тогда
		СтрокиСценарияЗапуска[0].Запущен = 1;
		СтрокиСценарияЗапуска.ОбменДанными.Загрузка = Истина;
		СтрокиСценарияЗапуска.Записать();
	КонецЕсли;
	
КонецПроцедуры // ОтметитьГотовоКЗапуску()

// Удалить запись о ВП
//
// Параметры:
//  ВРМ - СправочникСсылка.ТЦВП
//
Процедура УдалитьВРМ(ВРМ) Экспорт
	
	Попытка
		
		Объект = ВРМ.ПолучитьОбъект();
		
		Если Объект <> Неопределено Тогда
			Объект.ОбменДанными.Загрузка = Истина;
			Объект.Удалить();
		КонецЕсли;
		
	Исключение
		// Может возникнуть исключение при конкурентной выгрузке ВРМ.
		// Исключение в этой секции не является критичным с точки зрения теста и тестового механизма.
	КонецПопытки;
	
КонецПроцедуры // УдалитьВРМ()

// Изменить имя ВРМ
//
// Праметры:
//  ИмяВРМ - Строка
//  Номер - Номер ВРМ
//
Процедура ИзменитьИмяВРМ(ИмяВРМ, Номер, СсылкаВРМ) Экспорт
	
	НачатьТранзакцию();
	ЭтотОбъект = СсылкаВРМ.ПолучитьОбъект();
	ЭтотОбъект.ОбменДанными.Загрузка = Истина;
	ЭтотОбъект.Наименование = ИмяВРМ;
	ЭтотОбъект.Номер = Номер;
	ЭтотОбъект.Записать();
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры // ИзменитьИмяВРМ()

// Возвращает параметры, используемые при инициализации ВРМ
//
//
// Возвращаемое значение:
//   Структура:
//   	НомерСеанса - Число
//   	Перечисления - Структура, кэш перечислений для клиента
//   	Клон - СправочникСсылка.ТЦПользователи
//
Функция ПолучитьПараметрыДляВРМ() Экспорт

	ПараметрыДляВРМ = Новый Структура;
	ПараметрыДляВРМ.Вставить("Клон", ТекущийКлон());
	ПараметрыДляВРМ.Вставить("НомерСеанса", НомерСеансаИнформационнойБазы());
	ПараметрыДляВРМ.Вставить("Перечисления", ПолучитьПеречисления());
	
	Возврат ПараметрыДляВРМ;

КонецФункции // ПолучитьПараметрыДляВРМ()

// Создать объект ВРМ
//
// Параметры:
//  
//
Процедура СоздатьВРМ(Наименование, Клиент, ИмяКомпьютера, НомерСессии, Пользователь, Клон, Порт, Ссылка) Экспорт
	
	ТЦОбщий.ЗаписатьВЖурнал("Создание ВРМ: " + Символы.ПС + Символы.Таб + Клон + " (" + Пользователь + ")", "ВРМ");
	ПараметрыСеанса.ТЦТипКлиентскогоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.ВРМ;
	
	ЭтотОбъект = Ссылка.ПолучитьОбъект();
	Если ЭтотОбъект = Неопределено Тогда
		ЭтотОбъект = Справочники.ТЦВП.СоздатьЭлемент();
		ЭтотОбъект.УстановитьСсылкуНового(Ссылка);
	КонецЕсли;
	
	КомпьютерВРМ = НайтиКомпьютер(ИмяКомпьютера);
	ЭтотОбъект.ОбменДанными.Загрузка = Истина;
	ЭтотОбъект.Наименование = Наименование;
	ЭтотОбъект.Клиент = Клиент;
	ЭтотОбъект.Компьютер = КомпьютерВРМ;
	ЭтотОбъект.НомерСессии = НомерСессии;
	ЭтотОбъект.Пользователь = Пользователь;
	ЭтотОбъект.Клон = Клон;
	ЭтотОбъект.Порт = Порт;
	ЭтотОбъект.ЭтапЗавершен = Ложь;
	
	ЭтотОбъект.Записать();
	
	// Удалим ВРМ с таким же портом, которые могли остаться в следствие нештатного завершения ВРМ прошедших тестов.
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Ссылка
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |ГДЕ
	               |	ТЦВП.Порт = &Порт
	               |	И ТЦВП.Компьютер = &КомпьютерВРМ
	               |	И ТЦВП.Ссылка <> &Ссылка";
				   
	Запрос.УстановитьПараметр("Порт",	Порт);
	Запрос.УстановитьПараметр("КомпьютерВРМ",	КомпьютерВРМ);
	Запрос.УстановитьПараметр("Ссылка",	ЭтотОбъект.Ссылка);
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Попытка
			ДубльВРМ = Выборка.Ссылка.ПолучитьОбъект();
			ДубльВРМ.ОбменДанными.Загрузка = Истина;
			ДубльВРМ.Удалить();			
		Исключение
			// Данное действие не является критичным, запишем информацию об ошибке как предупреждение.
			ТЦОбщий.ЗаписатьВЖурнал(ИнформацияОбОшибке(), Перечисления.ТЦСтатусСообщения.Предупреждение);
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // СоздатьВРМ()

// Получить параметры загрузки ВРМ
//
// Параметры:
//  
//
// Возвращаемое значение:
//  
//
Функция ПолучитьПараметрыЗагрузкиВРМ(ВРМ) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВРМ", ВРМ);
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦВП.Роль КАК Роль,
	               |	ТЦВП.Роль.Обработка КАК Обработка,
	               |	ТЦВП.Роль.Параметры КАК ПараметрыОбработки,
	               |	ТЦВП.Роль.Наименование КАК ИмяРоли,
	               |	ТЦВП.Клиент.Компьютер.Наименование КАК ИмяКомпьютера,
	               |	ТЦВП.НомерСессии КАК НомерСессии,
	               |	ТЦВП.Пользователь.Наименование КАК ИмяПользователя,
	               |	ТЦВП.ПродолжатьРаботуМеждуИтерациями
	               |ИЗ
	               |	Справочник.ТЦВП КАК ТЦВП
	               |ГДЕ
	               |	ТЦВП.Ссылка = &ВРМ";
	Выборка = Запрос.Выполнить().Выбрать();
	Параметры = Новый Структура;
	
	Пока Выборка.Следующий() Цикл
		Параметры.Вставить("Обработка", Выборка.Обработка);
		Параметры.Вставить("ПараметрыОбработки", Выборка.ПараметрыОбработки);
		Параметры.Вставить("Роль", Выборка.Роль);
		Параметры.Вставить("ИмяРоли", Выборка.ИмяРоли);
		Параметры.Вставить("ИмяКомпьютера", Выборка.ИмяКомпьютера);
		Параметры.Вставить("ИмяПользователя", Выборка.ИмяПользователя);
		Параметры.Вставить("НомерСессии", Выборка.НомерСессии);
		Параметры.Вставить("ПродолжатьРаботуМеждуИтерациями", Выборка.ПродолжатьРаботуМеждуИтерациями);
	КонецЦикла;
	
	Возврат Параметры;
	
КонецФункции // ПолучитьПараметрыЗагрузкиВРМ()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПОЛЬЗОВАТЕЛЯМИ

// Получить параметры пользователя из ссылки на справочник ТЦПользователи
//
// Параметры:
//  Пользователь - СправочникСсылка.ТЦПользователи
//
// Возвращаемое значение:
//  Структура
//   Имя - Строка
//   Домен - Строка
//   Пароль - Строка
//   ТипАутентификации - ПеречислениеСсылка.ТЦТипАутентификации
//
Функция ПараметрыПользователя(Пользователь) Экспорт
	
	Параметры = Новый Структура;
	
	УстановитьПривилегированныйРежим(Истина);
	НачатьТранзакцию();
	
	Попытка
		Если Пользователь.ТипАутентификации = Перечисления.ТЦТипАутентификации.АутентификацияОС Тогда
			ПользовательОС = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				Новый УникальныйИдентификатор(Пользователь.ИдентификаторПользователяИБ)
			).ПользовательОС;
			ИмяПользователя = ТЦОбщий.РазделитьСтроку(ПользовательОС, "\");
			
			Если ИмяПользователя.Количество() > 1 Тогда
				Параметры.Вставить("Имя", ИмяПользователя[1]);
				Параметры.Вставить("Домен", ИмяПользователя[0]);
			Иначе
				Параметры.Вставить("Имя", Пользователь.Имя);
			КонецЕсли;
		Иначе
			Параметры.Вставить("Имя", Пользователь.Имя);
		КонецЕсли;
		
		Параметры.Вставить("Пароль", Пользователь.Пароль);
		Параметры.Вставить("ТипАутентификации", Пользователь.ТипАутентификации);
		ЗафиксироватьТранзакцию();
		Возврат Параметры;
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции // ПараметрыПользователя()

// Проверить наличие клонированных пользователей в соответствии со сценарием
// Если пользователей недостаточно, добавить их.
// Если пользователи есть, то проверить, соответствуют ли они оригиналу.
// Если не соответствуют, то привести их в соответствие.
//
// Параметры:
//  ФактическаяСтруктура - ТаблицаЗначений - фактическая структура сценария
//  ИспользоватьТолькоКлонов - Булево — указывает, что нужно использовать только клоны пользователей, оригиналы — не используются.
// 	ТаблицаЗначений - таблица, описывающая резерв ВРМ. Имеет следующие поля:
// 		Роль - СправочникСсылка.ТЦРоли, роль пользователя в данном сценарии
//		Пользователь - СправочникСсылка.ТЦПользователи, пользователь с данной ролью
//		Клиент - СправочникСсылка.ТЦКлиенты, клиент, с помощью которого данный пользователь подключается к информационной базе
//		Количество - Число, количество клонов, использующих текущее сочетание Роль-Пользователь-Клиент
//
Процедура НастроитьПользователей(СтруктураСценария, ИспользоватьТолькоКлонов) Экспорт
	
	Перем КлонИБ;
	Перем ПользовательИБ;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Попытка

		ТекущееКоличествоОбъектов = 0;
		КоличествоОбъектовВТранзакции = 50;
		
		ПользователиКлоны = Новый Соответствие;
		ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей();
		Для Каждого ТекПользователь Из ВсеПользователи Цикл
			Если Найти(ТекПользователь.Имя, "_ТЦ") > 0 Тогда
				ПользователиКлоны.Вставить(ТекПользователь.Имя, ТекПользователь);
			КонецЕсли;
		КонецЦикла;

		ТаблицаПользователей = СтруктураСценария.Скопировать();
		ТаблицаПользователей.Свернуть("Пользователь", "Количество");
		
		БСПИспользуется = БСППодсистемаИспользуется("Пользователи");
		ПользователиИБКлоны = Новый Массив;

		Для Каждого СтрокаТаблицы Из ТаблицаПользователей Цикл
			
			ПользовательТЦ = СтрокаТаблицы.Пользователь;
			ИдентификаторПользователяИБ = СтрокаТаблицы.Пользователь.ИдентификаторПользователяИБ;
			ИмяПользователяИБ = ПользовательТЦ.Имя;
			КоличествоКлиентов = СтрокаТаблицы.Количество;
			
			Попытка
				ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
					Новый УникальныйИдентификатор(ИдентификаторПользователяИБ)
				);
			Исключение
				ПользовательИБ = Неопределено;
			КонецПопытки;
			
			Если ПользовательИБ = Неопределено Тогда
				ВызватьИсключение
					"Пользователь информационной базы (" + ИмяПользователяИБ + ") не найден. " +
					"Создайте заново этого пользователя или выберите другого пользователя в настройках сценария.";
			КонецЕсли;
			
			Если КоличествоКлиентов < 2 и Не ИспользоватьТолькоКлонов Тогда
				Продолжить;
			ИначеЕсли ПользовательИБ.АутентификацияОС Тогда
				ВызватьИсключение
					"Пользователь информационной базы (" + ИмяПользователяИБ + ") с аутентификацией ОС не может быть использован для запуска нескольких ВРМ. " +
					"Установите этому пользователю аутентификацию 1С:Предприятия или используйте для запуска нескольких ВРМ разных пользователей с аутентификацией ОС.";
			КонецЕсли;
			
			ПользователиИБКлоны.Очистить();
			Для Сч = 1 По КоличествоКлиентов Цикл
				
				Если ТекущееКоличествоОбъектов = 0 Тогда
					НачатьТранзакцию();
				КонецЕсли;
				
				ИмяКлона = ИмяКлона(ПользовательИБ, Сч);

				// Сначала ищем клона по имени, чтобы не возникло коллизий при назначении имен клонам
				КлонИБ = Неопределено;
				
				Попытка
					КлонИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ИмяКлона);
				Исключение
					КлонИБ = ПользователиКлоны.Получить(ИмяКлона);
				КонецПопытки;
				
				Если КлонИБ = Неопределено Тогда
					Попытка
						КлонИБ = КлонПользователя(ИдентификаторПользователяИБ, Сч);
					Исключение
						КлонИБ = Неопределено;
					КонецПопытки;
				КонецЕсли;
				
				Если КлонИБ = Неопределено Тогда
					КлонИБ = ПользователиИнформационнойБазы.СоздатьПользователя();
				КонецЕсли;
				
				СинхронизироватьПользователей(КлонИБ, ПользовательИБ, ИмяКлона);
				
				ИдентификаторКлона = Строка(КлонИБ.УникальныйИдентификатор);
				ЗарегистрироватьКлонИБ(ИдентификаторПользователяИБ, Сч, ИдентификаторКлона);
				ПользователиИБКлоны.Добавить(КлонИБ);
				
				// Записываем клонов в справочник ТЦПользователи
				КлонСсылка = ПользовательИБПоИдентификатору(ИдентификаторКлона);
				ЭтоНовый = Ложь;
				
				Если Не ЗначениеЗаполнено(КлонСсылка) Тогда
					Клон = Справочники.ТЦПользователи.СоздатьЭлемент();
					Клон.ОбменДанными.Загрузка = Истина;
					Клон.ИдентификаторПользователяИБ = ИдентификаторКлона;
					ЭтоНовый = Истина;
				Иначе
					Клон = КлонСсылка.ПолучитьОбъект();
				КонецЕсли;
				
				Оригинал = ПользовательТЦ.ПолучитьОбъект();
				
				СинхронизироватьПользователейИБ(Клон, Оригинал, ИмяКлона, ЭтоНовый);
				
				ТекущееКоличествоОбъектов = ТекущееКоличествоОбъектов + 1;
				Если ТекущееКоличествоОбъектов = КоличествоОбъектовВТранзакции Тогда
					ТекущееКоличествоОбъектов = 0;
					ЗафиксироватьТранзакцию();
				КонецЕсли;
				
			КонецЦикла;
			
			Если ТекущееКоличествоОбъектов > 0 Тогда
				ТекущееКоличествоОбъектов = 0;
				ЗафиксироватьТранзакцию();
			КонецЕсли;
			
			Если БСПИспользуется Тогда
				БСПДобавитьНеобходимыеПрава(ПользователиИБКлоны, ИдентификаторПользователяИБ, ИмяПользователяИБ);
			КонецЕсли;
		КонецЦикла;
	Исключение
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры // НастроитьПользователей()

// Привести одного пользователя в соответствии с другому
//
// Параметры:
//  Пользователь - ПользовательИнформационнойБазы
//  Оригинал - ПользовательИнформационнойБазы
//  НовоеИмя - Строка, новое имя пользователя
//
Процедура СинхронизироватьПользователей(Пользователь, Оригинал, НовоеИмя)
	
	Изменен = Ложь;
	
	Если Пользователь.АутентификацияОС <> Оригинал.АутентификацияОС Тогда
		Пользователь.АутентификацияОС = Оригинал.АутентификацияОС;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.АутентификацияСтандартная <> Оригинал.АутентификацияСтандартная Тогда
		Пользователь.АутентификацияСтандартная = Оригинал.АутентификацияСтандартная;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ЗапрещеноИзменятьПароль <> Оригинал.ЗапрещеноИзменятьПароль Тогда
		Пользователь.ЗапрещеноИзменятьПароль = Оригинал.ЗапрещеноИзменятьПароль;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.Имя <> НовоеИмя Тогда
		Пользователь.Имя = НовоеИмя;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ОсновнойИнтерфейс <> Оригинал.ОсновнойИнтерфейс Тогда
		Пользователь.ОсновнойИнтерфейс = Оригинал.ОсновнойИнтерфейс;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ПоказыватьВСпискеВыбора <> Ложь Тогда
		Пользователь.ПоказыватьВСпискеВыбора = Ложь;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ПолноеИмя <> НовоеИмя Тогда
		Пользователь.ПолноеИмя = НовоеИмя;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ПользовательОС <> Оригинал.ПользовательОС Тогда
		Пользователь.ПользовательОС = Оригинал.ПользовательОС;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.РежимЗапуска <> Оригинал.РежимЗапуска Тогда
		Пользователь.РежимЗапуска = Оригинал.РежимЗапуска;
		Изменен = Истина;
	КонецЕсли;
	
	Для каждого Роль Из Оригинал.Роли Цикл
		Если Не Пользователь.Роли.Содержит(Роль) Тогда
			Пользователь.Роли.Добавить(Роль);
			Изменен = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Удаляемые = Новый Массив;
	
	Для каждого Роль Из Пользователь.Роли Цикл
		Если Не Оригинал.Роли.Содержит(Роль) Тогда
			Удаляемые.Добавить(Роль);
			Изменен = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Роль Из Удаляемые Цикл
		Пользователь.Роли.Удалить(Роль);
	КонецЦикла;
	
	Если Пользователь.СохраняемоеЗначениеПароля <> Оригинал.СохраняемоеЗначениеПароля Тогда
		Пользователь.СохраняемоеЗначениеПароля = Оригинал.СохраняемоеЗначениеПароля;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.Язык <> Оригинал.Язык Тогда
		Пользователь.Язык = Оригинал.Язык;
		Изменен = Истина;
	КонецЕсли;
	
	// Синхронизируем параметры разделения данных
	СтруктураРазделителейОригинала = Оригинал.РазделениеДанных;
	СтруктураРазделителейПользователя = Пользователь.РазделениеДанных;
	Для Каждого СтрокаРазделителя Из СтруктураРазделителейОригинала Цикл
		СтруктураРазделителейПользователя.Вставить(
			СтрокаРазделителя.Ключ,
			СтрокаРазделителя.Значение
		);
		Изменен = Истина;
	КонецЦикла;
	
	Если Изменен Тогда
		Пользователь.Записать();
	КонецЕсли;
	
КонецПроцедуры // СинхронизироватьПользователей()

// Привести одного пользователя ИБ в соответствии с другому
//
// Параметры:
//  Пользователь - СправочникОбъект.ТЦПользователи
//  Оригинал - СправочникОбъект.ТЦПользователи
//  НовоеИмя - Строка, новое имя пользователя
//  ЭтоНовый - Булево, Истина - новый пользователь
//
Процедура СинхронизироватьПользователейИБ(Пользователь, Оригинал, НовоеИмя, ЭтоНовый)
	
	Изменен = ЭтоНовый;
	
	Если Пользователь.Наименование <> НовоеИмя Тогда
		Пользователь.Наименование = НовоеИмя;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.Имя <> НовоеИмя Тогда
		Пользователь.Имя = НовоеИмя;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.Пароль <> Оригинал.Пароль Тогда
		Пользователь.Пароль = Оригинал.Пароль;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.ТипАутентификации <> Оригинал.ТипАутентификации Тогда
		Пользователь.ТипАутентификации = Оригинал.ТипАутентификации;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.Описание <> Оригинал.Описание Тогда
		Пользователь.Описание = Оригинал.Описание;
		Изменен = Истина;
	КонецЕсли;
	
	Если Пользователь.СсылкаНаОригинальногоПользователя <> Оригинал.Ссылка Тогда
		Пользователь.СсылкаНаОригинальногоПользователя = Оригинал.Ссылка;
		Изменен = Истина;
	КонецЕсли;
	
	Если Изменен Тогда
		Пользователь.Записать();
	КонецЕсли;
	
КонецПроцедуры // СинхронизироватьПользователейИБ()

// Выяснить, есть ли в системе разделители
//
// Возвращаемое значение:
//  Булево - Истина, если в системе есть разделители
//
Функция ЕстьРазделители() Экспорт
	
	НеИспользовать = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.НеИспользовать;
	
	Для каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если ОбщийРеквизит.РазделениеДанных <> НеИспользовать Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции // ЕстьРазделители()

// Формирует строку из используемых разделителей пользователя ИБ
//   ПользовательИнформационнойБазы - тип ПользовательИнформационнойБазы
// Возвращаемое значение:
//  Строка вида ИмяРазделителя = Значение, ...
//
Функция РазделителиПользователяИБВСтроку(ПользовательИнформационнойБазы) Экспорт
	
	СтруктураРазделителей = ПользовательИнформационнойБазы.РазделениеДанных;
	НеИспользовать = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.НеИспользовать;
	РазделителиВСтроку = "";
	Для Каждого СтрокаРазделителя Из СтруктураРазделителей Цикл
		Если НЕ ПустаяСтрока(РазделителиВСтроку) Тогда
			РазделителиВСтроку = ", " + РазделителиВСтроку;
		КонецЕсли;
		РазделителиВСтроку = РазделителиВСтроку + СтрокаРазделителя.Ключ + " = " + СтрокаРазделителя.Значение;
	КонецЦикла;
	Возврат РазделителиВСтроку;
КонецФункции // ЕстьРазделители()

// Устанавливает разделение сеанса.
//
// Параметры:
// СтруктураРазделителей - структура
//  Ключ - Имя общего реквизита - Строка
//  Значение - Произвольный тип
//
Процедура УстановитьРазделениеСеанса(Знач СтруктураРазделителей = Неопределено) Экспорт
	
	Если НЕ ЕстьРазделители() Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ СеансЗапущенБезРазделителей() Тогда
		ВызватьИсключение(НСтр("ru = 'Изменить разделение сеанса возможно только из сеанса запущенного без указания разделителей'"));
	КонецЕсли;
	
	Если СтруктураРазделителей = Неопределено Тогда
		СтруктураРазделителей = Новый Структура;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	ИменаПараметровСеансаДляОчистки = Новый Массив;
	ИменаПараметровСеанса = Новый Массив;
	
	НеИспользовать = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.НеИспользовать;
	Разделители = Метаданные.ОбщиеРеквизиты;
	Для Каждого Разделитель Из Разделители Цикл
		
		Если Разделитель.РазделениеДанных = НеИспользовать Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРазделителя = Разделитель.Имя;
		ПараметрСеансаЗначение = Разделитель.ЗначениеРазделенияДанных.Имя;
		ПараметрСеансаИспользование = Разделитель.ИспользованиеРазделенияДанных.Имя;
		
		Если СтруктураРазделителей.Свойство(ИмяРазделителя) Тогда
			ПараметрыСеанса[ПараметрСеансаЗначение] = Число(СтруктураРазделителей[ИмяРазделителя]);
			ПараметрыСеанса[ПараметрСеансаИспользование] = Истина;
			ИменаПараметровСеанса.Добавить(ПараметрСеансаЗначение);
			ИменаПараметровСеанса.Добавить(ПараметрСеансаИспользование);
		ИначеЕсли ЗначениеЗаполнено(ПараметрыСеанса[ПараметрСеансаЗначение]) Тогда
			ИменаПараметровСеансаДляОчистки.Добавить(ПараметрСеансаЗначение);
			ИменаПараметровСеансаДляОчистки.Добавить(ПараметрСеансаИспользование);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИмяПараметраРазделения Из ИменаПараметровСеанса Цикл
		ИндексПараметра = ИменаПараметровСеансаДляОчистки.Найти(ИмяПараметраРазделения);
		Если ИндексПараметра <> Неопределено Тогда
			ИменаПараметровСеансаДляОчистки.Удалить(ИндексПараметра);
		КонецЕсли;
	КонецЦикла;
	
	Если СтруктураРазделителей.Количество() > 0 Тогда
		ОчиститьПараметрыСеанса(ИменаПараметровСеансаДляОчистки, ИменаПараметровСеанса);
	Иначе
		Если БСППодсистемаИспользуется("РаботаВМоделиСервиса") Тогда
			// Если внедрена подсистема "Работа в модели сервиса", то 
			// выключать разделение нужно с её помощью
			МодульРаботаВМоделиСервиса = Вычислить("РаботаВМоделиСервиса");
			МодульРаботаВМоделиСервиса.УстановитьРазделениеСеанса(Ложь);
		Иначе
			ОчиститьПараметрыСеанса(ИменаПараметровСеансаДляОчистки, ИменаПараметровСеанса);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Определяет, сеанс запущен с разделителями или без.
//
// Возвращаемое значение:
// Булево.
//
Функция СеансЗапущенБезРазделителей()
	
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().РазделениеДанных.Количество() = 0;
	
КонецФункции

// Переводит параметры сеанса в состояние "Не установлено".
//
Процедура ОчиститьПараметрыСеанса(Знач МассивПараметровДляОчистки = Неопределено, Знач МассивИсключений = Неопределено)
	
	Если МассивПараметровДляОчистки = Неопределено Тогда
		МассивПараметровДляОчистки = Новый Массив;
		Для Каждого ПараметрСеанса Из Метаданные.ПараметрыСеанса Цикл
			Если МассивИсключений = Неопределено ИЛИ МассивИсключений.Найти(ПараметрСеанса.Имя) = Неопределено Тогда
				МассивПараметровДляОчистки.Добавить(ПараметрСеанса.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если МассивПараметровДляОчистки.Количество() > 0 Тогда
		ПараметрыСеанса.Очистить(МассивПараметровДляОчистки);
	КонецЕсли;
	
КонецПроцедуры

Функция КлонПользователя(Знач ИдентификаторПользователяИБ, Знач НомерКлона)
	ИдентификаторКлона = РегистрыСведений.ТЦИдентификаторыКлоновИБ.Получить(Новый Структура(
		"ИдентификаторПользователяИБ, НомерКлона",
		ИдентификаторПользователяИБ,
		НомерКлона
	)).ИдентификаторКлона;
	Если ЗначениеЗаполнено(ИдентификаторКлона) Тогда
		
		УстановитьПривилегированныйРежим(Истина);
		
		Клон = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
			Новый УникальныйИдентификатор(ИдентификаторКлона)
		);
		
		Возврат Клон;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

Процедура ЗарегистрироватьКлонИБ(Знач ИдентификаторПользователяИБ, Знач НомерКлона, Знач ИдентификаторКлона)
	ЗаписьОКлоне = РегистрыСведений.ТЦИдентификаторыКлоновИБ.СоздатьМенеджерЗаписи();
	ЗаписьОКлоне.ИдентификаторПользователяИБ = ИдентификаторПользователяИБ;
	ЗаписьОКлоне.НомерКлона = НомерКлона;
	ЗаписьОКлоне.ИдентификаторКлона = ИдентификаторКлона;
	ЗаписьОКлоне.Записать();
КонецПроцедуры

Функция ТЦПользовательВПользовательИБ(ТЦПользователь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Результат = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
		Новый УникальныйИдентификатор(ТЦПользователь.ИдентификаторПользователяИБ)
	);
	
	Возврат Результат;
	
КонецФункции

// Найти оригинального пользователя по его клону
//
// Параметры:
//  Клон - СправочникСсылка.ТЦПользователи
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦПользователи - оригинал
//
Функция НайтиОригиналПоКлону(Клон) Экспорт
	СсылкаНаОригинальногоПользователя = Клон.СсылкаНаОригинальногоПользователя;
	
	Если СсылкаНаОригинальногоПользователя.Пустая() Тогда
		Возврат Клон
	Иначе
		Возврат СсылкаНаОригинальногоПользователя;
	КонецЕсли;
КонецФункции // ОригинальныйПользователь()


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С БСП

// Функция определяет используется ли подсистема управления доступом БСП
//
// Параметры:
//  ИмяПодсистемы - Строка, имя проверяемой подсистемы
//
// Взвращаемое значение:
//  Истина - Подсистема используется
//  Ложь - Подсистема не используется
//
Функция БСППодсистемаИспользуется(ИмяПодсистемы) Экспорт
	
	Результат = Истина;
	
	РодительскаяПодсистема = Метаданные.Подсистемы.Найти("СтандартныеПодсистемы");
	Если РодительскаяПодсистема = Неопределено Тогда
		Результат = Ложь;
	Иначе
		Если РодительскаяПодсистема.Подсистемы.Найти(ИмяПодсистемы) = Неопределено Тогда
			Результат = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает Истина, если выполняется обновление информационной базы
//
// Возвращаемое значение:
//   Булево
//
Функция БСПВыполняетсяОбновлениеИнформационнойБазы() Экспорт

	Результат = Ложь;
	Попытка
		Результат = Вычислить("ОбновлениеИнформационнойБазы.НеобходимоОбновлениеИнформационнойБазы()");
	Исключение
		Результат = Ложь;
	КонецПопытки;
	
	Возврат Результат;

КонецФункции // БСПВыполняетсяОбновлениеИнформационнойБазы()

// Проверяет, используется ли справочник ИдентификаторыОбъектовМетаданных в справочнике ПрофилиГруппДоступа.
//
// Возвращаемое значение:
//   Булево
//
Функция БСПИспользуетсяСправочникИдентификаторовОбъектовМетаданных() Экспорт

	Если Метаданные.Справочники.Найти("ИдентификаторыОбъектовМетаданных") <> Неопределено Тогда
		
		МассивДляОписанияТипов = Новый Массив;
		МассивДляОписанияТипов.Добавить(Тип("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
		
		ОписаниеСправочникаОбъектовМетаданных = Новый ОписаниеТипов(МассивДляОписанияТипов);
		
		Если Метаданные.Справочники.ПрофилиГруппДоступа.ТабличныеЧасти.Роли.Реквизиты.Роль.Тип
			= ОписаниеСправочникаОбъектовМетаданных Тогда
		
			Возврат Истина;
		
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции // БСПИспользуетсяСправочникИдентификаторовОбъектовМетаданных()

// Проверяет, что объект метаданных зарегистрирован в справочнике «Идентификаторы объектов метаданных».
//
// Параметры:
//  ПолноеИмяМетаданных  - Строка - полное имя метаданных в справочнике «Идентификаторы объектов метаданных».
//
// Возвращаемое значение:
//   Булево   - Истина, если объект метаданных зарегистрирован в справочнике «Идентификаторы объектов метаданных».
//
Функция БСПМетаданныеЗарегистрированы(ПолноеИмяМетаданных) Экспорт

	Если НЕ БСПИспользуетсяСправочникИдентификаторовОбъектовМетаданных() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПолноеИмяМетаданных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ИдентификаторыОбъектовМетаданных.Ссылка
	               |ИЗ
	               |	Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	               |ГДЕ
	               |	ИдентификаторыОбъектовМетаданных.ПолноеИмя = &ПолноеИмя";
	
	Запрос.УстановитьПараметр("ПолноеИмя", ПолноеИмяМетаданных);
	Результат = НЕ Запрос.Выполнить().Пустой();
	
	Возврат Результат;

КонецФункции // МетаданныеЗарегистрированы()

// Проверяет, что подсистема ТестЦентр зарегистрирована в справочнике «Идентификаторы объектов метаданных».
//
// Возвращаемое значение:
//   Булево   - Истина, если подсистема ТестЦентр зарегистрирована в справочнике «Идентификаторы объектов метаданных».
//
Функция БСППодсистемаТЦЗарегистрирована() Экспорт

	Возврат БСПМетаданныеЗарегистрированы(ТЦОбщий.ПолноеИмяПодсистемыТестЦентр());

КонецФункции // МетаданныеЗарегистрированы()

// Процедура добавляет пользователям права необходимые для работы с механизмами БСП
//
// Параметры
//  ПользователиИБ - Массив, список клонированных пользователей ИБ
//  ИмяОригинала - Строка, имя оригинального пользователя
//
Процедура БСПДобавитьНеобходимыеПрава(ПользователиИБ, ИдентификаторОригинала, ИмяОригинала)
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОригиналИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
		Новый УникальныйИдентификатор(ИдентификаторОригинала)
	);
	
	РазделениеДанных = ОригиналИБ.РазделениеДанных;
	УстановитьРазделениеСеанса(РазделениеДанных);
	
	Оригинал = БСПНайтиПользователияПоИдентификатору(ИдентификаторОригинала);
	Если Не ЗначениеЗаполнено(Оригинал) Тогда
		
		УстановитьРазделениеСеанса();
		ВызватьИсключение
			"Пользователь """ + ИмяОригинала + """ не найден. " +
			"Создайте заново этого пользователя или выберите другого пользователя в настройках сценария.";
	КонецЕсли;
	
	СозданныеПользователи = БСПСоздатьПользователей(ПользователиИБ);
	
	Если БСППодсистемаИспользуется(ТЦОбщий.БСПИмяПодсистемыУправленияДоступом()) И ЗначениеЗаполнено(СозданныеПользователи) Тогда
		БСПСинхронизироватьГруппыДоступа(СозданныеПользователи, Оригинал);
		БСПСинхронизироватьГруппыПользователей(СозданныеПользователи, Оригинал);
	КонецЕсли;
	
	УстановитьРазделениеСеанса();
	
КонецПроцедуры

// Функция создает элементы в справочнике "Пользователи" подсистемы БСП
// 
// Параметры:
//  ПользователиИБ - Массив, пользователи ИБ на основании которых создаются элементы справочника "Пользователи"
//
// Возвращаемое значение:
//  Массив - список созданных элементов справочника "Пользователи"
//
Функция БСПСоздатьПользователей(ПользователиИБ)
	
	СозданныеПользователи = Новый Массив;
	Для Каждого ПользовательИБ Из ПользователиИБ Цикл
		
		Пользователь = БСПНайтиПользователияПоИдентификатору(ПользовательИБ.УникальныйИдентификатор);
		Если Не ЗначениеЗаполнено(Пользователь) Тогда
			
			Пользователь = Справочники.Пользователи.СоздатьЭлемент();
			Пользователь.Наименование = ПользовательИБ.Имя;
			Пользователь.ДополнительныеСвойства.Вставить("ОписаниеПользователяИБ", Новый Структура(
				"Действие, УникальныйИдентификатор", "Записать", ПользовательИБ.УникальныйИдентификатор
			));
			Если Метаданные.Справочники.Пользователи.ДлинаКода > 0 Тогда
				Пользователь.Код = Строка(ПользовательИБ.УникальныйИдентификатор) + ПользовательИБ.Имя;
			КонецЕсли;
			
			Пользователь.Записать();
			
		КонецЕсли;
		
		СозданныеПользователи.Добавить(Пользователь.Ссылка);
		
	КонецЦикла;
	
	Возврат СозданныеПользователи;
	
КонецФункции

// Процедура синхронизирует группы доступа оригинального пользователя и клонов
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПСинхронизироватьГруппыДоступа(СозданныеПользователи, Оригинал)
	
	БСПДобавитьВГруппыДоступа(СозданныеПользователи, Оригинал);
	БСПУдалитьИзГруппДоступа(СозданныеПользователи, Оригинал);
	
КонецПроцедуры

// Процедура добавляет клонов в группы доступа оригинального пользователя
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПДобавитьВГруппыДоступа(СозданныеПользователи, Оригинал)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|ГДЕ
	|	ГруппыДоступаПользователи.Пользователь = &Оригинал";
	Запрос.УстановитьПараметр("Оригинал", Оригинал);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КолонкаПоиска = "Пользователь";
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ГруппаДоступаОбъект = Выборка.ГруппаДоступа.ПолучитьОбъект();
		ТЧ = ГруппаДоступаОбъект.Пользователи;
		ГруппаИзмененна = Ложь;
		Для Каждого Пользователь Из СозданныеПользователи Цикл
			
			РезультатПоиска = ТЧ.Найти(Пользователь, КолонкаПоиска);
			Если Не ЗначениеЗаполнено(РезультатПоиска) Тогда
				Строка = ТЧ.Добавить();
				Строка.Пользователь = Пользователь;
				ГруппаИзмененна = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ГруппаИзмененна Тогда
			ГруппаДоступаОбъект.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет клонов из групп доступа к которым не относится оригинальный пользователь
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПУдалитьИзГруппДоступа(СозданныеПользователи, Оригинал)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|ГДЕ
	|	ГруппыДоступаПользователи.Пользователь = &Пользователь";
	Запрос.УстановитьПараметр("Пользователь", СозданныеПользователи[0]);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КолонкаПоиска = "Пользователь";
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ГруппаДоступаОбъект = Выборка.ГруппаДоступа.ПолучитьОбъект();
		ТЧ = ГруппаДоступаОбъект.Пользователи;
		РезультатПоиска = ТЧ.Найти(Оригинал, КолонкаПоиска);
		Если ЗначениеЗаполнено(РезультатПоиска) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Пользователь Из СозданныеПользователи Цикл
			
			СтрокаТЧ = ТЧ.Найти(Пользователь, КолонкаПоиска);
			Если СтрокаТЧ = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ТЧ.Удалить(СтрокаТЧ);
			
		КонецЦикла;
		
		ГруппаДоступаОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура синхронизирует группы пользователей оригинального пользователя с клонами
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПСинхронизироватьГруппыПользователей(СозданныеПользователи, Оригинал)
	
	БСПДобавитьВГруппыПользователей(СозданныеПользователи, Оригинал);
	БСПУдалитьИзГруппПользователей(СозданныеПользователи, Оригинал);
	
КонецПроцедуры

// Процедура добавляет клонов в группы пользователей оригинального пользователя
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПДобавитьВГруппыПользователей(СозданныеПользователи, Оригинал)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыПользователейСостав.Ссылка КАК ГруппаПользователей
	|ИЗ
	|	Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|ГДЕ
	|	ГруппыПользователейСостав.Пользователь = &Оригинал";
	Запрос.УстановитьПараметр("Оригинал", Оригинал);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КолонкаПоиска = "Пользователь";
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ГруппаПользователейОбъект = Выборка.ГруппаПользователей.ПолучитьОбъект();
		ТЧ = ГруппаПользователейОбъект.Состав;
		ГруппаИзмененна = Ложь;
		Для Каждого Пользователь Из СозданныеПользователи Цикл
			
			РезультатПоиска = ТЧ.Найти(Пользователь, КолонкаПоиска);
			Если Не ЗначениеЗаполнено(РезультатПоиска) Тогда
				Строка = ТЧ.Добавить();
				Строка.Пользователь = Пользователь;
				ГруппаИзмененна = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ГруппаИзмененна Тогда
			ГруппаПользователейОбъект.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура удаляет клонов из групп пользователей в которых нет оригинального пользователя
//
// Параметры:
//  СозданныеПользователи - Массив, список клонов
//  Оригинал - СправочникСсылка.Пользователи, ссылка на оригинального пользователя
//
Процедура БСПУдалитьИзГруппПользователей(СозданныеПользователи, Оригинал)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ГруппыПользователейСостав.Ссылка КАК ГруппаПользователей
	|ИЗ
	|	Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|ГДЕ
	|	ГруппыПользователейСостав.Пользователь = &Пользователь";
	Запрос.УстановитьПараметр("Пользователь", СозданныеПользователи[0]);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	КолонкаПоиска = "Пользователь";
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ГруппаПользователейОбъект = Выборка.ГруппаПользователей.ПолучитьОбъект();
		ТЧ = ГруппаПользователейОбъект.Состав;
		РезультатПоиска = ТЧ.Найти(Оригинал, КолонкаПоиска);
		Если ЗначениеЗаполнено(РезультатПоиска) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Пользователь Из СозданныеПользователи Цикл
			
			СтрокаТЧ = ТЧ.Найти(Пользователь, КолонкаПоиска);
			Если СтрокаТЧ = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ТЧ.Удалить(СтрокаТЧ);
			
		КонецЦикла;
		
		ГруппаПользователейОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура создает группу доступа Тест-центр
//
Процедура БСПСоздатьГруппуДоступаТестЦентр() Экспорт
	
	ИмяГруппыДоступа = ТЦОбщий.ИмяГруппыДоступаТестЦентр();
	
	Попытка
		ГруппаДоступа = Справочники.ГруппыДоступа.НайтиПоНаименованию(ИмяГруппыДоступа, Истина);
	Исключение
		Возврат;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ГруппаДоступа) Тогда
		Возврат;
	КонецЕсли;
	
	ПрофильТестЦентра = БСППолучитьПрофильТестЦентр();
	
	Если ПрофильТестЦентра = Неопределено Тогда
		ВызватьИсключение
			"Недостаточно прав на работу со справочником ""Профили групп доступа"".";
	КонецЕсли;
	
	ГруппаДоступа = Справочники.ГруппыДоступа.СоздатьЭлемент();
	ГруппаДоступа.Наименование = ИмяГруппыДоступа;
	ГруппаДоступа.Профиль = ПрофильТестЦентра;
	
	ГруппаДоступа.Записать();
	
КонецПроцедуры

// Функция создает профиль включающий в себя роль "ТестЦентр"
//
// Возвращаемое значение:
//  СправочникСсылка.ПрофилиГруппДоступа - ссылка на профиль "ТестЦентр"
//
Функция БСППолучитьПрофильТестЦентр()
	
	ИмяПрофиля = "Тест-центр";
	
	Попытка
		Профиль = Справочники.ПрофилиГруппДоступа.НайтиПоНаименованию(ИмяПрофиля, Истина);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(Профиль) Тогда
		Возврат Профиль;
	КонецЕсли;
	
	// Проверим, испольуется ли справочник ИдентификаторыОбъектовМетаданных в подсистеме управления доступом.
	ИспользуетсяСправочникОбъектовМетаданных = БСПИспользуетсяСправочникИдентификаторовОбъектовМетаданных();
	
	Профиль = Справочники.ПрофилиГруппДоступа.СоздатьЭлемент();
	Профиль.Наименование = ИмяПрофиля;
		
	Если ИспользуетсяСправочникОбъектовМетаданных Тогда
		
		МодульОбщегоНазначения = Вычислить("ОбщегоНазначения");
		Профиль.Роли.Добавить().Роль = МодульОбщегоНазначения.ИдентификаторОбъектаМетаданных(Метаданные.Роли["ТестЦентр"]);
		
		НоваяСтрока = Профиль.Назначение.Добавить();
		НоваяСтрока.ТипПользователей = Справочники.Пользователи.ПустаяСсылка();
		
	Иначе
		
		Профиль.Роли.Добавить().Роль = "ТестЦентр";
		
	КонецЕсли;
	
	Профиль.Записать();
	
	Возврат Профиль.Ссылка;
	
КонецФункции

// Создает группу доступа и профиль группы доступа для Тест-центра, либо указывает,
// что нужно запустить обновление или дождаться его окончания.
//
// Возвращаемое значение:
//   Строка или Неопределено  - Неопределено — если дополнительных действий не требуется
//								"ЗапуститьОбновление" — если требуется запустить обновление информационной базы
//								"ОжидатьОбновления" — если требуется дождаться окончания обновления информационной базы
//
Функция БСППодготовитьПодсистемуУправленияДоступом() Экспорт

	Если НЕ ТЦСервер.БСППодсистемаИспользуется(ТЦОбщий.БСПИмяПодсистемыУправленияДоступом()) Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИмяГруппыДоступа = ТЦОбщий.ИмяГруппыДоступаТестЦентр();
	
	Попытка
		ГруппаДоступа = Справочники.ГруппыДоступа.НайтиПоНаименованию(ИмяГруппыДоступа, Истина);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ГруппаДоступа) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если БСППодсистемаТЦЗарегистрирована() Тогда
		БСПСоздатьГруппуДоступаТестЦентр();
		Возврат Неопределено;
	КонецЕсли;
	
	Если БСПВыполняетсяОбновлениеИнформационнойБазы() Тогда
		Возврат "ОжидатьОбновления";
	КонецЕсли;
	
	Возврат "ЗапуститьОбновление";

КонецФункции // БСППодготовитьПодсистемуУправленияДоступом()

// Функция находит пользователя по имени
//
// Возвращаемое занчение:
//  СправочникСсылка.Пользователи - ссылка на найденного пользователя
//
Функция БСПНайтиПользователияПоИмени(Имя)
	
	ПользовательИБ = БСПНайтиПользователяИБПоИмени(Имя);
	Если ПользовательИБ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Справочники.Пользователи.НайтиПоРеквизиту("ИдентификаторПользователяИБ", ПользовательИБ.УникальныйИдентификатор);
	
КонецФункции

// Функция находит пользователя по уникальному идентификатору
//
// Возвращаемое занчение:
//  СправочникСсылка.Пользователи - ссылка на найденного пользователя
//
Функция БСПНайтиПользователияПоИдентификатору(Знач УникальныйИдентификатор)
	Если ТипЗнч(УникальныйИдентификатор) = Тип("Строка") Тогда
		УникальныйИдентификатор = Новый УникальныйИдентификатор(УникальныйИдентификатор);
	КонецЕсли;
	
	Возврат Справочники.Пользователи.НайтиПоРеквизиту("ИдентификаторПользователяИБ", УникальныйИдентификатор);
	
КонецФункции

// Функция находит пользователя ИБ по имени
//
// Возвращаемое занчение:
//  ПользовательИнформационнойБазы - ссылка на найденного пользователя
//
Функция БСПНайтиПользователяИБПоИмени(Имя)
	
	Попытка
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(Имя);
	Исключение
		ПользовательИБ = Неопределено;
	КонецПопытки;
	
	Возврат ПользовательИБ;
	
КонецФункции

// Функция определяет доступность роли у текущего пользователия
//
// Параметры:
//  ИмяРоли - Строка, имя роли
//
// Возвращаемое значение:
//  Истина - доступна
//  Ложь - не доступна
//
Функция БСПРольДоступна(ИмяРоли) Экспорт
	
	Возврат РольДоступна(ИмяРоли);
	
КонецФункции

// Процедура добавляет в профиль доступа роли
//
// Параметры:
//  СписокРолей - Массив, список добаляемых ролей
//  Профиль - СправочникСсылка.ПрофилиГруппДоступа, профиль в который добавляются роли
//
Процедура БСПДобавитьРолиВПрофиль(СписокРолей, Профиль = Неопределено)
	
	Профиль = ?(Профиль = Неопределено, БСППолучитьПрофильТестЦентр(), Профиль);
	ПрофильОбъект = Профиль.ПолучитьОбъект();
	ПрофильИзменен = Ложь;
	Для Каждого Роль Из СписокРолей Цикл
		
		Если ПрофильОбъект.Роли.Найти(Роль, "Роль") = Неопределено Тогда
			Врем = ПрофильОбъект.Роли.Добавить();
			Врем.Роль = Роль;
			ПрофильИзменен = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПрофильИзменен Тогда
		ПрофильОбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПРАВАМИ ДОСТУПА

// Функция подбирает необходимые роли для корректной работы подсистемы
//
// Параметры:
//  ИмяПодсистемы - Строка, имя подсистемы
//
// Возвращаемое значение:
//  Массив - список необходимых ролей
//
Функция ПодобратьПраваДляПодсистемы(ИмяПодсистемы) Экспорт
	
	ИтоговыйНаборРолей = Новый Массив;
	Подсистема = Метаданные.Подсистемы.Найти(ИмяПодсистемы);
	
	НеобходимыеПрава = Новый Массив;
	ИскомыеОбъекты = Новый Соответствие;
	ИскомыеОбъекты.Вставить("Справочники", "СправочникСсылка");
	ИскомыеОбъекты.Вставить("Документы", "ДокументСсылка");
	
	ТипыОбъектовТестЦентра = ПолучитьТипыОбъектовПодсистемы(Подсистема.Состав, ИскомыеОбъекты);
	
	Регистры = НайтиЗависимостиОтРегистровСведений(ТипыОбъектовТестЦентра);
	
	Если ЗначениеЗаполнено(Регистры) Тогда
		НеобходимыеПрава.Очистить();
		НеобходимыеПрава.Добавить("Чтение");
		НеобходимыеПрава.Добавить("Изменение");
		НеобходимыеРолиДляРегистров = ПодобратьРолиДляОбъектов(Регистры, НеобходимыеПрава);
	КонецЕсли;
	
	Планы = НайтиЗависимостиОтПлановОбмена(Подсистема.Состав);
	
	Если ЗначениеЗаполнено(Планы) Тогда
		НеобходимыеПрава.Очистить();
		НеобходимыеПрава.Добавить("Чтение");
		НеобходимыеРолиДляПланов = ПодобратьРолиДляОбъектов(Планы, НеобходимыеПрава);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НеобходимыеРолиДляРегистров) Тогда
		Для Каждого Роль Из НеобходимыеРолиДляРегистров Цикл
			ИтоговыйНаборРолей.Добавить(Роль.Имя);
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НеобходимыеРолиДляПланов) Тогда
		Для Каждого Роль Из НеобходимыеРолиДляПланов Цикл
			Если ИтоговыйНаборРолей.Найти(Роль.Имя) = Неопределено Тогда
				ИтоговыйНаборРолей.Добавить(Роль.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ИтоговыйНаборРолей;
	
КонецФункции

// Функция ищет в подсистеме указанные объекты
//
// Параметры:
//  СоставПодсистемы - КоллекцияЗначенийСвойстваОбъектаМетаданных, объекты в которых нужно искать
//  ИскомыеОбъекты - Соответствие, Ключ - вид искомого объекта (Документы, Справочники)
//                                 Значение - тип искомого объекта (ДокументСсылка, СправочникОбъект)
//
// Возвращаемое значение:
//  Массив - массив найденных типов объектов
//
Функция ПолучитьТипыОбъектовПодсистемы(СоставПодсистемы, ИскомыеОбъекты)
	
	ТипыОбъектов = Новый Массив;
	
	Для Каждого Объект Из СоставПодсистемы Цикл
		Для Каждого ВидОбъекта Из ИскомыеОбъекты Цикл
			
			ВидОбъектаЕЧ = ПолучитьВидОбъекта(Объект.ПолноеИмя());
			Если ВидОбъектаЕЧ = Лев(ВидОбъекта.Значение, СтрДлина(ВидОбъектаЕЧ)) И Метаданные[ВидОбъекта.Ключ].Найти(Объект.Имя)<> Неопределено Тогда
				ТипыОбъектов.Добавить(Тип(ВидОбъекта.Значение + "." + Объект.Имя));
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТипыОбъектов;
	
КонецФункции

// Функция получает вид объекта из его полного наименования
//
// Параметры:
//  ПолноеИмя - Строка, полное имя объекта
//
// Возвращаемое значение:
//  Строка - вид объекта
//
Функция ПолучитьВидОбъекта(ПолноеИмя)
	
	ПозицияТочнки = Найти(ПолноеИмя, ".");
	ВидОбъекта = Лев(ПолноеИмя, ПозицияТочнки - 1);
	
	Возврат ВидОбъекта;
	
КонецФункции

// Функция находит регистры, которые могут влиять на указанные типы
//
// Параметры:
//  ТипыОбъектов - Массив, массив типов, которые необходимо проверять
//
// Возвращаемое значение:
//  Массив - список найденных регистров
//
Функция НайтиЗависимостиОтРегистровСведений(ТипыОбъектов)
	
	Регистры = Новый Массив;
	
	Для Каждого Регистр Из Метаданные.РегистрыСведений Цикл
		Для Каждого Измерение Из Регистр.Измерения Цикл
			
			Если Измерение.Ведущее Тогда
				ТипыИзмерения = Измерение.Тип.Типы();
				Для Каждого ТипОбъекта Из ТипыОбъектов Цикл
					
					Если ТипыИзмерения.Найти(ТипОбъекта) <> Неопределено Тогда
						Если Регистры.Найти(Регистр) = Неопределено Тогда
							Регистры.Добавить(Регистр);
						КонецЕсли;
					КонецЕсли;
					
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Возврат Регистры;
	
КонецФункции

// Функция ищет планы обмена в которых участвуют объекты подсистемы
//
// Параметры:
//  СоставПодсистемы - КоллекцияЗначенийСвойстваОбъектаМетаданных, объекты которые нужно проверять
//
// Возвращаемое значение:
//  Массив - список планов обмена в составе которых есть объекты
//
Функция НайтиЗависимостиОтПлановОбмена(СоставПодсистемы)
	
	Планы = Новый Массив;
	Для Каждого ПланОбмена Из Метаданные.ПланыОбмена Цикл
		Для Каждого ОбъектПодсистемы Из СоставПодсистемы Цикл
			
			Если ПланОбмена.Состав.Содержит(ОбъектПодсистемы) Тогда
				Если Планы.Найти(ПланОбмена) = Неопределено Тогда
					Планы.Добавить(ПланОбмена);
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Возврат Планы;
	
КонецФункции

// Функция подбирает набор ролей необходимых для работы с регистрами
//
// Параметры:
//  Объекты - Массив, список объектов
//  НеобходимыеПрава - Массив, список прав которые должны быть доступны
//
// Возвращаемое значение:
//  Массив - список необходимых ролей
//
Функция ПодобратьРолиДляОбъектов(Объекты, НеобходимыеПрава)
	
	ПодобранныеРоли = Новый Массив;
	ДопустимыеРоли = Новый Массив;
	
	Для Каждого Объект Из Объекты Цикл
		
		ДопустимыеРоли.Очистить();
		Для Каждого Роль Из Метаданные.Роли Цикл
			
			РольДопустима = Истина;
			Для Каждого Право Из НеобходимыеПрава Цикл
				Если Не ПравоДоступа(Право, Объект, Роль) Тогда
					РольДопустима = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если РольДопустима Тогда
				ДопустимыеРоли.Добавить(Роль);
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не ЗначениеЗаполнено(ДопустимыеРоли) Тогда
			ВызватьИсключение
					"Нет ни одной роли у которой есть необходимые права на объект: " + Объект;
		КонецЕсли;
		Если ДопустимыеРоли.Количество() > 1 Тогда
			ПодобраннаяРоль = ВыбратьПодходящуюРоль(ДопустимыеРоли, Объект);
		Иначе
			ПодобраннаяРоль = ДопустимыеРоли[0];
		КонецЕсли;
		
		Если ПодобранныеРоли.Найти(ПодобраннаяРоль) = Неопределено Тогда
			ПодобранныеРоли.Добавить(ПодобраннаяРоль);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПодобранныеРоли;
	
КонецФункции

// Функция выбирает наиболее подходящую роль из списка ролей
//
// Параметры:
//  ДопустимыеРоли - Массив, список ролей из которых выбирать
//
// Возвращаемое значение:
//  ОбъектМетаданных: Роль - выбранная роль
//
Функция ВыбратьПодходящуюРоль(ДопустимыеРоли, ОбъектМетаданных)
	
	ВыбраннаяРоль = Неопределено;
	Для Каждого Роль Из ДопустимыеРоли Цикл
		
		ВесВыбраннойРоли = ВзвеситьРоль(ВыбраннаяРоль, ОбъектМетаданных);
		ВесТекущейРоли = ВзвеситьРоль(Роль, ОбъектМетаданных);
		Если ВесТекущейРоли < ВесВыбраннойРоли Тогда
			ВыбраннаяРоль = Роль;
		ИначеЕсли ВесТекущейРоли = ВесВыбраннойРоли И ВыбраннаяРоль.Имя = "ПолныеПрава" Тогда
			ВыбраннаяРоль = Роль;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ВыбраннаяРоль;
	
КонецФункции

// Функция взвешивает роль относительно того какие у нее права
//
// Параметры:
//  Роль - ОбъектМетаданных: Роль, роль вес которой надо узнать
//
// Возвращаемое значение:
//  Число - вес роли
//
Функция ВзвеситьРоль(Роль, ОбъектМетаданных)
	
	Если Роль = Неопределено Тогда
		Возврат 999999;
	КонецЕсли;
	
	ВесРоли = 0;
	Если ПравоДоступа("Чтение", ОбъектМетаданных, Роль) Тогда
		ВесРоли = ВесРоли + 1;
	КонецЕсли;
	Если ПравоДоступа("Изменение", ОбъектМетаданных, Роль) Тогда
		ВесРоли = ВесРоли + 2;
	КонецЕсли;
	Если ПравоДоступа("Просмотр", ОбъектМетаданных, Роль) Тогда
		ВесРоли = ВесРоли + 3;
	КонецЕсли;
	Если ПравоДоступа("Редактирование", ОбъектМетаданных, Роль) Тогда
		ВесРоли = ВесРоли + 4;
	КонецЕсли;
	
	Возврат ВесРоли;
	
КонецФункции

// Функция проверяет есть ли необходимые права у оригинальных пользователей
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии, сценарий выполнения
//  НеобходимыеРоли - Массив, список обязательных ролей
//
// Возвращаемое значение:
//  Истина - прав не хватает
//  Ложь - все права есть
//
Функция ПроверитьПраваОригинальныхПользователей(Сценарий, НеобходимыеРоли) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДобавляемыеРоли = Новый Массив;
	Для Каждого Роль Из НеобходимыеРоли Цикл
		РольОбъект = Метаданные.Роли.Найти(Роль);
		Для Каждого СтрокаСценария Из Сценарий.Структура Цикл
			
			ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				Новый УникальныйИдентификатор(СтрокаСценария.Пользователь.ИдентификаторПользователяИБ)
			);
			Если БСППодсистемаИспользуется(ТЦОбщий.БСПИмяПодсистемыУправленияДоступом()) 
				И ПользовательИБ.Роли.Содержит(Метаданные.Роли["ПолныеПрава"]) 
			Тогда
				Продолжить;
			КонецЕсли;
			Если Не ПользовательИБ.Роли.Содержит(РольОбъект) Тогда
				ДобавляемыеРоли.Добавить(РольОбъект.Имя);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Возврат ДобавляемыеРоли;
	
КонецФункции

// Процедура устанавливает необходимые права оригинальным пользователям
//
// Параметры:
//  Сценарий - СправочникСсылка.ТЦСценарии, сценарий выполнения
//  НеобходимыеРоли - Массив, список обязательных ролей
//
Процедура УстановитьПраваОргинальныхПользователей(Сценарий, НеобходимыеРоли) Экспорт
	
	УправлениеДоступомБСПИспользуется = БСППодсистемаИспользуется(ТЦОбщий.БСПИмяПодсистемыУправленияДоступом());
	СписокРолей = Новый Массив;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Для Каждого Роль Из НеобходимыеРоли Цикл
		РольОбъект = Метаданные.Роли.Найти(Роль);
		Для Каждого СтрокаСценария Из Сценарий.Структура Цикл
			
			ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
				Новый УникальныйИдентификатор(СтрокаСценария.Пользователь.ИдентификаторПользователяИБ)
			);
			Если Не ПользовательИБ.Роли.Содержит(РольОбъект) Тогда
				Если УправлениеДоступомБСПИспользуется Тогда
					СписокРолей.Добавить(Роль);
					Прервать;
				Иначе
					ПользовательИБ.Роли.Добавить(РольОбъект);
					ПользовательИБ.Записать();
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЦикла;
	
	Если УправлениеДоступомБСПИспользуется Тогда
		БСПДобавитьРолиВПрофиль(СписокРолей);
	КонецЕсли;
	
КонецПроцедуры


///////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНАЯ ФУНКЦИОНАЛЬНОСТЬ

// Получить порядковый номер состояния выполнения теста
//
// Параметры:
//  Состояние - ПеречислениеСсылка.ТЦСостояние
//
// Возвращаемое значение:
//  Число - порядковый номер состояния
//
Функция НомерСостояния(Состояние) Экспорт
	
	Если Состояние = Перечисления.ТЦСостояние.Подготовка Тогда
		Возврат 1;
	ИначеЕсли Состояние = Перечисления.ТЦСостояние.Инициализация Тогда
		Возврат 2;
	ИначеЕсли Состояние = Перечисления.ТЦСостояние.Выполнение Тогда
		Возврат 3;
	ИначеЕсли Состояние = Перечисления.ТЦСостояние.ЗаписьРезультатов Тогда
		Возврат 4;
	ИначеЕсли Состояние = Перечисления.ТЦСостояние.УдалениеДанных Тогда
		Возврат 5;
	ИначеЕсли Состояние = Перечисления.ТЦСостояние.Неактивен Тогда
		Возврат 6;
	КонецЕсли;
	
КонецФункции // НомерСостояния()

// Преобразовать массив в таблицу значений
//
// Параметры:
//  Значения - Массив
//  ИмяКолонки - Строка, имя колонки таблиы значений для массива
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция МассивВТаблицуЗначений(Значения, ИмяКолонки) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Типы = Новый Массив;
	Типы.Добавить(ТипЗнч(Значения[0]));
	ТипСсылки = Новый ОписаниеТипов(Типы);
	Таблица.Колонки.Добавить(ИмяКолонки, ТипСсылки);
	
	Для каждого Значение Из Значения Цикл
		СтрокаТаблицы = Таблица.Добавить();
		СтрокаТаблицы[ИмяКолонки] = Значение;
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции // МассивВТаблицуЗначений()

// Преобразовать соответствие в таблицу значений
//
// Параметры:
//  Значения - Массив
//  ИмяКолонки - Строка, имя колонки таблиы значений для массива
//
// Возвращаемое значение:
//  ТаблицаЗначений
//
Функция СоответствиеВТаблицуЗначений(Значения, ИмяКолонки) Экспорт
	
	ТипЗначения = ТипЗнч(Неопределено);
	
	Для каждого Значение Из Значения Цикл
		ТипЗначения = ТипЗнч(Значение.Ключ);
		Прервать;
	КонецЦикла;
	
	Таблица = Новый ТаблицаЗначений;
	Типы = Новый Массив;
	Типы.Добавить(ТипЗначения);
	ТипСсылки = Новый ОписаниеТипов(Типы);
	Таблица.Колонки.Добавить(ИмяКолонки, ТипСсылки);
	
	Для каждого Значение Из Значения Цикл
		СтрокаТаблицы = Таблица.Добавить();
		СтрокаТаблицы[ИмяКолонки] = Значение.Ключ;
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции // СоответствиеВТаблицуЗначений()

// Преобразовать ТаблицуЗначений в Массив Структур
//
// Параметры:
//  Таблица - ТаблицаЗначений, преобразуемая таблица
//
// Возвращаемое значение:
//  Массив - состоящий из структур с полями соответствующими колонкам таблицы
//
Функция ТаблицуЗначенийВМассивСтруктур(Таблица) Экспорт
	
	Результат = Новый Массив;
	
	Для каждого СтрокаТаблицы Из Таблица Цикл
		Элемент = Новый Структура;
		
		Для каждого Колонка Из Таблица.Колонки Цикл
			Элемент.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
		КонецЦикла;
		
		Результат.Добавить(Элемент);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ТаблицуЗначенийВМассивСтруктур()

// Получить имя текущего пользователя
//
// Возвращаемое значение:
//  Строка - полное имя пользователя
//
Функция ИмяТекущегоПользователя() Экспорт
	
	Имя = ПолноеИмяПользователя();
	
	Если ПустаяСтрока(Имя) Тогда
		Имя = ИмяПользователя();
	КонецЕсли;
	
	Возврат Имя;
	
КонецФункции // ИмяТекущегоПользователя()

// Получить имя пользователя
//
// Праметры:
//  Пользователь - СправочникСсылка.ТЦПользователи
//
// Возвращаемое значение:
//  Строка - имя пользователя
//
Функция ИмяПользователяИБ(Пользователь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЦПользователи.Имя
	               |ИЗ
	               |	Справочник.ТЦПользователи КАК ТЦПользователи
	               |ГДЕ
	               |	ТЦПользователи.Ссылка = &Пользователь";
				   
	Запрос.УстановитьПараметр("Пользователь", Пользователь);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		ВызватьИсключение "Не удалось определить имя пользователя Тест-центра по ссылке " + Пользователь;
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Имя
	
КонецФункции // ИмяПользователяИБ()

// Получить пользователя  по имени
//
// Параметры:
//  ИмяКлона - Строка, имя клона
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦПользователи
//
Функция ПользовательИБПоИмени(ИмяКлона) Экспорт
	
	Возврат Справочники.ТЦПользователи.НайтиПоРеквизиту("Имя", ИмяКлона);
	
КонецФункции // ПользовательИБПоИмени()

// Получить текущий клон
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦПользователи
//
Функция ТекущийКлон() Экспорт
	
	Возврат ПользовательИБПоИдентификатору(ПользователиИнформационнойБазы.ТекущийПользователь().УникальныйИдентификатор);
	
КонецФункции // ПользовательИБПоИдентификатору()

// Получить пользователя  по идентификатору
//
// Параметры:
//  ИдентификаторПользователяИБ - Строка, имя клона
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦПользователи
//
Функция ПользовательИБПоИдентификатору(ИдентификаторПользователяИБ) Экспорт
	
	Возврат Справочники.ТЦПользователи.НайтиПоРеквизиту("ИдентификаторПользователяИБ", Строка(ИдентификаторПользователяИБ));
	
КонецФункции // ПользовательИБПоИдентификатору()

// Получить ссылку по уникальному идентификатору
//
// Параметры:
//  Ид - Строка, уникальный идентификатор
//  ТипОбъекта - Строка, тип объекта метаданных
//  ИмяОбъекта - Строка, имя объекта метаданных
//
// Возвращаемое значение:
//  Ссылка
//
Функция СсылкаПоИдентификатору(Ид, ТипОбъекта, ИмяОбъекта) Экспорт
	
	Перем Ссылка;
	
	Идентификатор = Новый УникальныйИдентификатор(Ид);
	Выполнить "Ссылка = " + ТипОбъекта + "." + ИмяОбъекта + ".ПолучитьСсылку(Идентификатор);";
	Возврат Ссылка;
	
КонецФункции // СсылкаПоИдентификатору()

// Получить имя объекта, как оно записано в метаданных
//
// Параметры:
//  Объект - Произвольный
//
// Возвращаемое значение:
//  Строка - имя объекта, как оно записано в метаданных
//
Функция ИмяПеречисления(Перечисление) Экспорт
	
	Представление = Строка(Перечисление);
	МетаданныеПеречисления = Перечисление.Метаданные();
	Имена = МетаданныеПеречисления.ЗначенияПеречисления;
	
	Для Каждого ВозможноеИмя Из Имена Цикл
		Если ВозможноеИмя.Синоним = Представление Тогда
			Имя = ВозможноеИмя.Имя;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Имя;
	
КонецФункции // ИмяПеречисления()

// Строка соединения с информационной базой на сервере
//
// Возвращаемое значение:
//  Строка - строка соединения
//
Функция СтрокаСоединенияИнформационнойБазыНаСервере() Экспорт
	
	Возврат СтрокаСоединенияИнформационнойБазы();
	
КонецФункции // СтрокаСоединенияИнформационнойБазыНаСервере()

// Записать в журнал сообщение
//
// Параметры:
//  ТекстОшибки - Строка, описание ошибки
//  Событие - Строка, наименование события
//  Важность - ПеречислениеСсылка.ТЦСтатусСообщения
//  ЭтоОшибка - Булево, признак того, что сообщение содержит описание ошибки
//
Процедура ЗаписатьВЖурнал(ТекстОшибки, Событие, Важность, ЭтоОшибка) Экспорт
	
	Имя = ?(Событие = Неопределено, "Тест-центр", Событие);
	
	Если Важность = Неопределено Тогда
		Если ЭтоОшибка Тогда
			Уровень = УровеньЖурналаРегистрации.Ошибка;
		Иначе
			Уровень = УровеньЖурналаРегистрации.Информация;
		КонецЕсли;
	Иначе
		Если Важность = Перечисления.ТЦСтатусСообщения.Ошибка Тогда
			Уровень = УровеньЖурналаРегистрации.Ошибка;
		ИначеЕсли Важность = Перечисления.ТЦСтатусСообщения.Предупреждение Тогда
			Уровень = УровеньЖурналаРегистрации.Предупреждение;
		ИначеЕсли Важность = Перечисления.ТЦСтатусСообщения.Информация Тогда
			Уровень = УровеньЖурналаРегистрации.Информация;
		КонецЕсли;
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(Имя, Уровень,, "Тест-центр", ТекстОшибки);
	
КонецПроцедуры // ЗаписатьВЖурнал()

// Сформировать отчет по протоколу журнала регистрации
//
// Параметры:
//  Начало - Дата, время начала событий
//  Окончание - Дата, время окончания событий
//  Док - ТабличныйДокумент, документ, в который будет выведен отчет
//
Процедура СформироватьОтчетПоПротоколу(Начало, Окончание, Док) Экспорт
	
	Журнал = Новый ТаблицаЗначений;
	Фильтр = Новый Структура;
	Фильтр.Вставить("ДатаНачала", Начало);
	Фильтр.Вставить("ДатаОкончания", Окончание + 1);
	Фильтр.Вставить("Данные", "Тест-центр");
	Колонки = "Уровень, Дата, ИмяПользователя, Компьютер, Событие, Комментарий";
	ВыгрузитьЖурналРегистрации(Журнал, Фильтр, Колонки);
	ОписаниеЖурнала = Новый Структура;
	ОписаниеЖурнала.Вставить("Журнал", Журнал);
	
	Схема = ПолучитьОбщийМакет("ТЦПротокол");
	СформироватьОтчет(Схема, Док,, ОписаниеЖурнала);
	
КонецПроцедуры // СформироватьОтчетПоПротоколу()

// Сформировать указанный отчет
//
// Параметры:
//  
//
Процедура СформироватьОтчет(Схема, Док, Параметры = Неопределено, Данные = Неопределено) Экспорт
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(Схема));
	КомпоновщикНастроек.ЗагрузитьНастройки(Схема.НастройкиПоУмолчанию);
	
	Если Параметры <> Неопределено Тогда
		Для каждого Параметр Из Параметры Цикл
			КомпоновщикНастроек.Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(
				Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(Схема, КомпоновщикНастроек.ПолучитьНастройки());
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	
	Если Данные = Неопределено Тогда
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	Иначе
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, Данные);
	КонецЕсли;
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(Док);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	Док.ПоказатьУровеньГруппировокСтрок(0);
	
КонецПроцедуры // СформироватьОтчет()

// Формирует отчет по производительности
//
// Параметры:
//  Тест  - ДокументСсылка.ТЦТест
//  ТабличныйДокумент  - ТабличныйДокумент
//
Процедура СформироватьОтчетПоПроизводительности(Тест, ТабличныйДокумент) Экспорт

	СисИнфо = Новый СистемнаяИнформация;
	ВерсияПлатформы = СисИнфо.ВерсияПриложения;
	
	Это82 = Ложь;           
	Если ТЦОбщий.СравнитьВерсии(ВерсияПлатформы, "8.3") < 0 Тогда
		СхемаКомпоновкиДанных = ПолучитьОбщийМакет("ТЦСКДРезультатыЗамеровПроизводительности82");
		Это82 = Истина;
	Иначе
		СхемаКомпоновкиДанных = ПолучитьОбщийМакет("ТЦСКДРезультатыЗамеровПроизводительности");
	КонецЕсли;
	
	НастройкиСКД = СхемаКомпоновкиДанных.НастройкиПоУмолчанию;
	ПараметрТест = НастройкиСКД.ПараметрыДанных.Элементы.Найти(Новый ПараметрКомпоновкиДанных("Тест"));
	ПараметрТест.Значение = Тест;
	ПараметрТест.Использование = Истина;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, НастройкиСКД);

	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, , , Это82);

	ТабличныйДокумент.Очистить();

	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ТабличныйДокумент);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
КонецПроцедуры // СформироватьОтчетПоПроизводительности()

// Формирует отчет по ошибкам
//
// Параметры:
//  Тест  - ДокументСсылка.ТЦТест
//  ТабличныйДокумент  - ТабличныйДокумент
//
Процедура СформироватьОтчетПоОшибкам(Тест, ТабличныйДокумент) Экспорт
	
	СхемаКомпоновкиДанных = ПолучитьОбщийМакет("ТЦСКДОшибкиТеста");
	
	НастройкиСКД = СхемаКомпоновкиДанных.НастройкиПоУмолчанию;
	ПараметрТест = НастройкиСКД.ПараметрыДанных.Элементы.Найти(Новый ПараметрКомпоновкиДанных("Тест"));
	ПараметрТест.Значение = Тест;
	ПараметрТест.Использование = Истина;
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, НастройкиСКД);

	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);

	ТабличныйДокумент.Очистить();

	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ТабличныйДокумент);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
КонецПроцедуры

// Получить версию конфигурации
//
// Параметры:
//  
//
// Возвращаемое значение:
//  
//
Функция ВерсияКонфигурации() Экспорт
	
	Возврат Метаданные.Версия;
	
КонецФункции // ВерсияКонфигурации()

// Узнать, является ли клиент веб-клиентом
//
// Параметры:
//  
//
// Возвращаемое значение:
//  
//
Функция ЭтоВебКлиент(Клиент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Клиент", Клиент);
	Запрос.Текст = "
		|ВЫБРАТЬ
		|	ВЫБОР
		|		КОГДА ТипКлиента = ЗНАЧЕНИЕ(Перечисление.ТЦТипКлиента.Веб) ТОГДА
		|			Истина
		|		ИНАЧЕ
		|			Ложь
		|	КОНЕЦ КАК ЭтоВеб
		|ИЗ
		|	Справочник.ТЦКлиенты
		|ГДЕ
		|	Ссылка = &Клиент";
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ЭтоВеб;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции // ЭтоВебКлиент()

Функция ПолучитьКлиентаПоОписанию(ОписаниеСтрокиСценария, ПоляПоиска, ЕстьВеб, ЕстьРазделение)
	
	МассивПолейПоиска = ТЦОбщий.РазделитьСтроку(ПоляПоиска, ",");
	Запрос = Новый Запрос;
	ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ 1
	|	ТЦКлиенты.Ссылка
	|ИЗ
	|	Справочник.ТЦКлиенты КАК ТЦКлиенты
	|ГДЕ";
	
	ПервоеУсловие = Истина;
	Для Каждого ПолеПоиска Из МассивПолейПоиска Цикл
		ЗначениеПоляПоиска = ОписаниеСтрокиСценария[ПолеПоиска];
		СтрокаУсловия = ПолучитьСтрокуУсловия(ПолеПоиска, ЗначениеПоляПоиска, ПервоеУсловие);		
		ТекстЗапроса = ТекстЗапроса + "
		|	" + СтрокаУсловия;
		Запрос.УстановитьПараметр(ПолеПоиска, ЗначениеПоляПоиска);
		ПервоеУсловие = ?(ПервоеУсловие, Ложь, ПервоеУсловие);
	КонецЦикла;
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Клиент = Выборка.Ссылка;
	Иначе
		КлиентОбъект = Справочники.ТЦКлиенты.СоздатьЭлемент();
		КлиентОбъект.ОбменДанными.Загрузка = Истина;
		
		Для Каждого ПолеПоиска Из МассивПолейПоиска Цикл
			ЗаполнитьЗначенияСвойств(КлиентОбъект, ОписаниеСтрокиСценария);
		КонецЦикла;
		
		КлиентОбъект.Наименование = ПолучитьПредставлениеКлиента(КлиентОбъект);
		
		КлиентОбъект.Записать();
		Клиент = КлиентОбъект.Ссылка;
	КонецЕсли;
	
	Возврат Клиент;
	
КонецФункции

Функция ПолучитьОписаниеСтрокиСценария(ОписаниеИсходногоСценария, КлючСтрокиСценария)
	
	ИндексСтроки = КлючСтрокиСценария.ИндексСтроки;
	НомерВРМ = КлючСтрокиСценария.НомерВРМ;
	
	СтрокаИсходногоСценария = ОписаниеИсходногоСценария[ИндексСтроки];
	
	Если НомерВРМ <= СтрокаИсходногоСценария.Количество Тогда
		// Получаем описание ВРМ из текущей строки сценария
		СтрокаСценария = ОписаниеИсходногоСценария[ИндексСтроки];
		НомерВРМ = НомерВРМ + 1;
	Иначе
		// Получаем описание ВРМ из следующей строки сценария
		НомерВРМ = 1;
		ИндексСтроки = ИндексСтроки + 1;
		
		СтрокаНайдена = Ложь;
		Пока ИндексСтроки < ОписаниеИсходногоСценария.Количество() Цикл
			
			Если ОписаниеИсходногоСценария[ИндексСтроки].Количество > 0 Тогда
				СтрокаНайдена = Истина;
				Прервать;
			КонецЕсли;
			
			ИндексСтроки = ИндексСтроки + 1;
		КонецЦикла;
		
		Если Не СтрокаНайдена Тогда
			Возврат Неопределено;
		КонецЕсли;

		СтрокаСценария = ОписаниеИсходногоСценария[ИндексСтроки];
		НомерВРМ = НомерВРМ + 1;
	КонецЕсли;
	
	КлючСтрокиСценария.ИндексСтроки = ИндексСтроки;
	КлючСтрокиСценария.НомерВРМ = НомерВРМ;
	
	Возврат СтрокаСценария;
	
КонецФункции

Функция ПолучитьСтрокуУсловия(ИмяПоля, ЗначениеПоля, ПервоеУсловие)
	
	СтрокаУсловия = ?(ПервоеУсловие, "", "И ");
	Если ТипЗнч(ЗначениеПоля) = Тип("Строка") Тогда
		СтрокаУсловия = СтрокаУсловия + "ПОДСТРОКА(" + ИмяПоля + ", 0, 1000) = &" + ИмяПоля;
	Иначе
		СтрокаУсловия = СтрокаУсловия + ИмяПоля + " = &" + ИмяПоля;
	КонецЕсли;
	
	Возврат СтрокаУсловия;
	
КонецФункции

// Определяет, используется ли подсистемы "БСП.ОценкаПроизводительности" или подсистема "ЗамерыПроизводительности"
//
// Возвращаемое значение:
//   Булево   - истина, если используется подсистема "БСП.ОценкаПроизводительности" или подсистема "ЗамерыПроизводительности"
//
Функция ОценкаПроизводительностиИспользуется() Экспорт

	Если БСППодсистемаИспользуется("ОценкаПроизводительности") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Подсистема = Метаданные.Подсистемы.Найти("ЗамерыПроизводительности");
	Если Подсистема <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;

КонецФункции // ОценкаПроизводительностиИспользуется()

// Обработчик для запуска фонового задания копирования документов
// в фоновом режиме работы обработки "ТЦКопированиеДокументов"
//
// Параметры:
//  ПараметрыФоновогоЗадания - Структура:
//		ВидыДокументовДляОбработки - ТаблицаЗначений
//				Колонки: Выбран - Булево
//						 ВидДокумента - Строка - Имя документа, как оно задано в конфигурации
//						 РеквизитДокументОснование - Строка - Имя реквизита, в котором хранится документ-основание
//		НачалоЭталонногоПериода - Дата - Начало периода, из которого выполняется копирование
//		ОкончаниеЭталонногоПериода - Дата - Конец периода, из которого выполняется копирование
//		НачалоЦелевогоПериода - Дата - Начало периода, в который выполняется копирование
//		ОкончаниеЦелевогоПериода - Дата - Конец периода, в который выполняется копирование
//		ПроводитьСкопированныеДокументы - Булево - Признак необходимости проведения скопированных документов
//
Процедура ЗапуститьКопированиеДокументовВФоне(ПараметрыФоновогоЗадания) Экспорт
	
	ОбработкаОбъект = Обработки.ТЦКопированиеДокументов.Создать();
	ОбработкаОбъект.ВыполнитьКопированиеПоВсемОбластям(
				ПараметрыФоновогоЗадания.ВидыДокументовДляОбработки,
				ПараметрыФоновогоЗадания.НачалоЭталонногоПериода, 
				ПараметрыФоновогоЗадания.ОкончаниеЭталонногоПериода, 
				ПараметрыФоновогоЗадания.НачалоЦелевогоПериода,
				ПараметрыФоновогоЗадания.ОкончаниеЦелевогоПериода,
				ПараметрыФоновогоЗадания.ПроводитьСкопированныеДокументы,
				Истина);
	
КонецПроцедуры


//////////////////////////////////////////////////////////////////////////////////////
// КЛИЕНТСКОЕ ПРИЛОЖЕНИЕ

// Получает элемент справочника ТЦУправлениеТестом по идентификатору текущего клиента
//
// Параметры:
//  Нет
//
// Возвращаемое значение
//  СправочникСсылка.ТЦУправлениеТестом
Функция ПолучитьЗаписьУправленияТестомПоИдентификатору() Экспорт
	
	ЭлементСправочника = Справочники.ТЦУправлениеТестом.НайтиПоНаименованию(ПараметрыСеанса.ТЦИдКлиентскогоПриложения, Истина);
	Возврат ЭлементСправочника;
	
КонецФункции //ПолучитьЗаписьУправленияТестомПоИдентификатору

Функция ПолучитьТипПриложенияПоИдентификатору() Экспорт
	Возврат ПолучитьЗаписьУправленияТестомПоИдентификатору().ТипПриложения;
КонецФункции //ПолучитьТипПриложенияПоИдентификатору

// Устанавливает тип клиентского приложения, сохраняет его в справочнике ТЦУправлениеТестом для идентификатора
// Устанавливет константу ТЦТипКлиентскогоПриложения
//
Процедура УстановитьТипКлиентскогоПриложения(ТипПриложения) Экспорт
	
	Если Не ТипПриложения = ПараметрыСеанса.ТЦТипКлиентскогоПриложения Тогда
		
		ЭлементУправлениеТестом = ПолучитьЗаписьУправленияТестомПоИдентификатору();
		Если ЗначениеЗаполнено(ЭлементУправлениеТестом) Тогда
			
			НовыйОбъект = ЭлементУправлениеТестом.ПолучитьОбъект();
			НовыйОбъект.ТипПриложения = ТипПриложения;
			НовыйОбъект.ОбменДанными.Загрузка = Истина;
			НовыйОбъект.Записать();
			ПараметрыСеанса.ТЦТипКлиентскогоПриложения = ТипПриложения;
			
		КонецЕсли;
		
		ПараметрыСеанса.ТЦТипКлиентскогоПриложения = ТипПриложения;
		
	КонецЕсли;
	
КонецПроцедуры //УстановитьТипКлиентскогоПриложения

// Устанавливает статус выполнения теста в справочнике ТЦУправлениеТестом
//
Процедура УстановитьСтатусВыполненияТеста(Флаг) Экспорт
	
	ЭлементУправлениеТестом = ПолучитьЗаписьУправленияТестомПоИдентификатору();
	Если ЗначениеЗаполнено(ЭлементУправлениеТестом) Тогда
		НовыйОбъект = ЭлементУправлениеТестом.ПолучитьОбъект();
		НовыйОбъект.Выполнение = Флаг;
		Если Флаг = Истина Тогда
			НовыйОбъект.ДатаОкончания = Неопределено;
			НовыйОбъект.Результат = Перечисления.ТЦРезультатВыполнения.ПустаяСсылка();
		КонецЕсли;
		
		НовыйОбъект.ОбменДанными.Загрузка = Истина;
		НовыйОбъект.Записать();
	КонецЕсли;
	
КонецПроцедуры //УстановитьСтатусВыполненияТеста

// Записывает идентификатор клиентского приложения в справочник
//
Процедура УстановитьИдКлиентскогоПриложения(ИмяКомпьютера = "",ТипКлиента = "") Экспорт
	
	НовыйОбъект = Справочники.ТЦУправлениеТестом.СоздатьЭлемент();
	НовыйОбъект.ОбменДанными.Загрузка = Истина;
	НовыйОбъект.Наименование = ПараметрыСеанса.ТЦИдКлиентскогоПриложения;
	Если ЗначениеЗаполнено(ИмяКомпьютера) Тогда
		НовыйОбъект.Хост = ИмяКомпьютера;
	КонецЕсли;
	Если ЗначениеЗаполнено(ТипКлиента) Тогда
		НовыйОбъект.ТипКлиента = ТипКлиента;
	КонецЕсли;
	Если ЗначениеЗаполнено(ПараметрыСеанса.ТЦТипКлиентскогоПриложения) Тогда
		НовыйОбъект.ТипПриложения = ПараметрыСеанса.ТЦТипКлиентскогоПриложения;
	КонецЕсли;
	НовыйОбъект.Записать();
	
КонецПроцедуры //УстановитьИдКлиентскогоПриложения

// Записывает результат и дату окончания для сессии
//
// Параметры:
//  Результат - ПеречислениеСсылка.ТЦРезультатВыполнения
//
Процедура УстановитьРезультатТеста(Результат) Экспорт
	
	Запись = ПолучитьЗаписьУправленияТестомПоИдентификатору();
	Если Запись <> Справочники.ТЦУправлениеТестом.ПустаяСсылка() Тогда
		Попытка
			Объект = Запись.ПолучитьОбъект();
			Объект.ДатаОкончания = ТекущаяДата();
			Объект.Результат = Результат;
			Объект.Выполнение = Ложь;
			Объект.ОбменДанными.Загрузка = Истина;
			Объект.Записать();
		Исключение
			ТЦОбщий.ЗаписатьВЖурнал(ИнформацияОбОшибке(), "УправлениеТестом");
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры//УстановитьДатуОкончания()

// Удаляет клиентское приложение из списка ТЦУправлениеТестом
//
Процедура УдалитьКлиентскоеПриложениеИзСписка() Экспорт
	
	ЭлементУправлениеТестом = ПолучитьЗаписьУправленияТестомПоИдентификатору();
	Если ЗначениеЗаполнено(ЭлементУправлениеТестом) Тогда
		НовыйОбъект = ЭлементУправлениеТестом.ПолучитьОбъект();
		НовыйОбъект.ОбменДанными.Загрузка = Истина;
		НовыйОбъект.Удалить();
	КонецЕсли;
	
КонецПроцедуры //УдалитьКлиентскоеПриложениеИзСписка

// Получает тип приложения из параметров сеанса
//
Функция ПолучитьТипПриложенияИзПараметровСеанса()
	
	Возврат ПараметрыСеанса.ТЦТипКлиентскогоПриложения;
	
КонецФункции //ПолучитьТипПриложенияИзПараметровСеанса

// Получает сценарий, который нужно запустить с помощью переданного клиентского приложения
//
// Параметры:
//  Запись - СправочникСсылка.ТЦУправлениеТестом - Клиентское приложение
//
// Возвращаемое значение:
//  СправочникСсылка.ТЦСценарии - есть сценарий должен быть запущен
//  Неопределено                - если сценарий запускать не требуется
//
Функция ПолучитьСценарий(Запись) Экспорт
	
	ТекДата = ТекущаяДата();
	Если (ЗначениеЗаполнено(Запись.ДатаНачала) И ТекДата > Запись.ДатаНачала) И
		(Не ЗначениеЗаполнено(Запись.ДатаОкончания) ИЛИ ТекДата < Запись.ДатаОкончания) И
		Не Запись.Выполнение Тогда
		
		Если ЗначениеЗаполнено(Запись.Сценарий) Тогда
			Возврат Запись.Сценарий;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции //ПолучитьСценарий

// Получает параметры сценария, который нужно запустить с помощью переданного клиентского приложения
//
// Параметры:
//  Запись - СправочникСсылка.ТЦУправлениеТестом - Клиентское приложение
//
// Возвращаемое значение:
//  Структура		 - если параметры запуска определены
//  Неопределено     - если параметры запуска не определены
//
Функция ПолучитьПараметрыСценария(Запись) Экспорт
	
	ПараметрыВыполнения = Запись.ПараметрыВыполнения.Получить();
	Возврат ПараметрыВыполнения;
	
КонецФункции // ПолучитьПараметрыСценария

//Проверка завершения агента
//
Функция ЗавершатьАгента(Запись) Экспорт
	
	ТекДата = ТекущаяДата();
	Если ЗначениеЗаполнено(Запись.ДатаОкончания) И ТекДата > Запись.ДатаОкончания
		И НЕ ЗначениеЗаполнено(Запись.Сценарий)
		И (Запись.Результат = Перечисления.ТЦРезультатВыполнения.ПустаяСсылка() )Тогда
		
		ТекстСообщения = "Завершение агента по дате окончания. ИД: " + Строка(Запись.Наименование) + "; ДатаОкончания: " + Строка(Запись.ДатаОкончания) + "; ТекДата: " + Строка(ТекДата);
		ЗаписьЖурналаРегистрации("ТестЦентр", УровеньЖурналаРегистрации.Предупреждение, "Завершение агента", ТекстСообщения);
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции //ЗавершатьАгента

// Получает интервал для запуска обрабочика опроса справочника ТЦУправлениеТестом
//
Функция ПолучитьИнтервалОпроса() Экспорт
	
	Интервал = Константы.ТЦИнтервалОпросаУправленияТестированием.Получить();
	Если Не ЗначениеЗаполнено(Интервал) Тогда 
		Интервал = 30;
	КонецЕсли;
	Возврат Интервал;
	
КонецФункции//ПолучитьИнтервал

// Устанавливает параметры сеанса для приложения
//
Процедура УстановитьПараметрыСеанса(ИменаПараметровСеанса) Экспорт
	
	Если ИменаПараметровСеанса = Неопределено
		Или ИменаПараметровСеанса.Найти("ТЦИдКлиентскогоПриложения") <> Неопределено Тогда
		ПараметрыСеанса.ТЦИдКлиентскогоПриложения = Строка(НомерСеансаИнформационнойБазы());
	КонецЕсли;
	
	Если ИменаПараметровСеанса = Неопределено
		Или ИменаПараметровСеанса.Найти("ТЦТипКлиентскогоПриложения") <> Неопределено Тогда
		ПараметрыСеанса.ТЦТипКлиентскогоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.ПустаяСсылка();
	КонецЕсли;
	
КонецПроцедуры // УстановитьПараметрыСеанса()

// Создает элемент для текущего сеанса в справочнике "ТЦУправлениеТестом"
// Возвращаемое значение:
//  Истина	- при старте приложения был передан тип клиентского приложения
//  Ложь	- при старте приложения был передан тип клиентского приложения
Функция ИнициализироватьУправлениеТестом(ИмяКомпьютера, ТипКлиента, ЭтоВРМ) Экспорт
	
	ОчиститьФантомныеСоединения();
	ТЦСервер.УстановитьИдКлиентскогоПриложения(ИмяКомпьютера,ТипКлиента);

	Если ЗначениеЗаполнено(ПараметрыСеанса.ТЦТипКлиентскогоПриложения) Тогда
		
		ЭтоВРМ = (ПараметрыСеанса.ТЦТипКлиентскогоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.ВРМ);
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Удаляет записи справочника ТЦУправлениеТестом, которые соответствуют
// несуществующим соединениям
//
Процедура ОчиститьФантомныеСоединения() Экспорт

	ТипТекущегоПриложения = ПараметрыСеанса.ТЦТипКлиентскогоПриложения;
	Запрос = Новый Запрос;
	Результат = Неопределено;
	
	НачатьТранзакцию();
	
	// Если текущее приложение является Агентом или ВРМ, то удалим только элементы справочника,
	// у которых наименование совпадает с номером текущем сеанса. (Они могли остатьтся в следствие аварийных завершений клиентов).
	Если ТипТекущегоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.АгентТЦ
		ИЛИ ТипТекущегоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.ВРМ Тогда

		Запрос.Текст = "ВЫБРАТЬ
		               |	ТЦУправлениеТестом.Ссылка
		               |ИЗ
		               |	Справочник.ТЦУправлениеТестом КАК ТЦУправлениеТестом
		               |ГДЕ
		               |	ТЦУправлениеТестом.Наименование = &ТекущийНомерСеанса
		               |
		               |ДЛЯ ИЗМЕНЕНИЯ
		               |	Справочник.ТЦУправлениеТестом";
					   
		Запрос.УстановитьПараметр("ТекущийНомерСеанса", ПараметрыСеанса.ТЦИдКлиентскогоПриложения);
		Результат = Запрос.Выполнить();
		
		Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ТЦУправлениеТестом");
			ЭлементБлокировки.ИсточникДанных = Результат;
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных("Ссылка", "Ссылка");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			Блокировка.Заблокировать();
		КонецЕсли;
	
	// Если роль текущему приложению еще не установлена, или роль равна Перечисления.ТЦТипКлиентскогоПриложения.УправлениеТестом
	// то попытаемся очистить все фантомные соединения
	ИначеЕсли НЕ ЗначениеЗаполнено(ТипТекущегоПриложения) ИЛИ ТипТекущегоПриложения = Перечисления.ТЦТипКлиентскогоПриложения.УправлениеТестом Тогда
		
		// Устанавливаем исключительную блокировку на справочник ТЦУправлениеТестом
		Если Метаданные.РежимУправленияБлокировкойДанных = Метаданные.СвойстваОбъектов.РежимУправленияБлокировкойДанныхПоУмолчанию.Управляемый Тогда
			Блокировка = Новый БлокировкаДанных;
			ЭлементБлокировки = Блокировка.Добавить("Справочник.ТЦУправлениеТестом");
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			Блокировка.Заблокировать();
		КонецЕсли;
		
		НомерТекущегоСеанса = НомерСеансаИнформационнойБазы();
		
		МассивНомеровСеансов = Новый Массив;
		МассивСеансов = ПолучитьСеансыИнформационнойБазы();
		Для Каждого СеансИБ из МассивСеансов Цикл
			
			Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
				Продолжить;
			КонецЕсли;
			
			МассивНомеровСеансов.Добавить(Строка(СеансИБ.НомерСеанса));
			
		КонецЦикла;
	
		Запрос.Текст = "ВЫБРАТЬ
		               |	ТЦУправлениеТестом.Ссылка
		               |ИЗ
		               |	Справочник.ТЦУправлениеТестом КАК ТЦУправлениеТестом
		               |ГДЕ
		               |	НЕ ТЦУправлениеТестом.Наименование В (&МассивНомеровСеансов)
		               |
		               |ДЛЯ ИЗМЕНЕНИЯ
		               |	Справочник.ТЦУправлениеТестом";
			   
		Запрос.УстановитьПараметр("МассивНомеровСеансов", МассивНомеровСеансов);
		Результат = Запрос.Выполнить();
		
	КонецЕсли;
		
	Если Результат.Пустой() Тогда
		ЗафиксироватьТранзакцию();
		Возврат;		
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Объект.ОбменДанными.Загрузка = Истина;
		
		РазделениеВключено = Ложь;
		Если ТЦСервер.БСППодсистемаИспользуется("РаботаВМоделиСервиса") Тогда
			Выполнить("РазделениеВключено = РаботаВМоделиСервиса.ИспользованиеРазделителяСеанса();");
		КонецЕсли;
		
		Если Не РазделениеВключено Тогда
			Попытка
				Объект.Удалить();
			Исключение
				ЗаписьЖурналаРегистрации("ТестЦентр", УровеньЖурналаРегистрации.Ошибка,, ОписаниеОшибки());
			КонецПопытки;
		КонецЕсли;
		
	КонецЦикла;
	
	ЗафиксироватьТранзакцию();

КонецПроцедуры

// Проверяет наличие клиентов, находящихся в режиме "Агент"
//
// Параметры:
//  Нет
//
// Возвращаемое значение:
//  Истина - Имеются запущенные агенты
//  Ложь   - Запущенные агенты отсутствуют
//
Функция ПроверитьНаличиеЗапущенныхАгентов() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ТипПриложения",Перечисления.ТЦТипКлиентскогоПриложения.АгентТЦ);
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТЦУправлениеТестом.Ссылка
	               |ИЗ
	               |	Справочник.ТЦУправлениеТестом КАК ТЦУправлениеТестом
	               |ГДЕ
	               |	ТЦУправлениеТестом.ТипПриложения = &ТипПриложения
	               |	И ТЦУправлениеТестом.Выполнение = ЛОЖЬ";
	Выборка = Запрос.Выполнить();
	
	Возврат Не Выборка.Пустой();
	
КонецФункции

// Получает используемый режим совместимости в виде строки
//
// Возвращаемое значение:
//   Строка   - Режим совместимости
//
Функция ПолучитьРежимСовместимостиКакСтроку() Экспорт

	Если Метаданные.РежимСовместимости = Метаданные.СвойстваОбъектов.РежимСовместимости.НеИспользовать Тогда
		Возврат "DontUse";
	КонецЕсли;
	
	РежимСтрока	= СокрЛП(Метаданные.РежимСовместимости);
	Результат	= "";
	
	Для Сч = 1 По СтрДлина(РежимСтрока) Цикл
		
		ТекСимвол = Сред(РежимСтрока, Сч, 1);
		Если ТекСимвол = "_" Тогда
			Результат = Результат + ".";
		ИначеЕсли СтрНайти("0123456789", ТекСимвол) > 0 Тогда
			Результат = Результат + ТекСимвол;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;

КонецФункции // ПолучитьРежимСовместимостиКакСтроку()

Процедура ЗаписатьПортАгента(АгентСсылка, ПортАгента) Экспорт
	
	АгентОбъект = АгентСсылка.ПолучитьОбъект();
	
	Если АгентОбъект = Неопределено Тогда
		ВызватьИсключение "Не найден нужный агент!";	
	КонецЕсли;
	
	АгентОбъект.Порт = ПортАгента;
	АгентОбъект.ОбменДанными.Загрузка = Истина;
	АгентОбъект.Записать();
	
КонецПроцедуры

// Получить имя клонированного пользователя
//
// Параметры:
//  ОригинальныйПользователь - ПользовательИБ - оригинальный пользователь информационной базы
//  Номер - Число, порядковый номер клона
//
// Возвращаемое значение:
//  Строка - имя клонированного пользователя
//
Функция ИмяКлона(ОригинальныйПользователь, Номер) Экспорт
	
	РазделениеДанных = ОригинальныйПользователь.РазделениеДанных;
	
	Если РазделениеДанных.Количество() <> 0 Тогда
		
		РазделителиСтрокой = "_(";
		ЭтоПервый = Истина;
		
		Для Каждого ТекущийРазделитель Из РазделениеДанных Цикл
			
			ТекущаяЧасть = "";
			Если НЕ ЭтоПервый Тогда
				ТекущаяЧасть = ", ";
			КонецЕсли;
			
			ЭтоПервый = Ложь;
			ИсходнаяЧасть = СокрЛП(ТекущийРазделитель.Значение);
			
			Если ТипЗнч(ТекущийРазделитель.Значение) = Тип("Строка") Тогда
				Длина = СтрДлина(ИсходнаяЧасть);
				Для Сч = 1 По Длина Цикл
					Если КодСимвола(ИсходнаяЧасть, Сч) > 31  Тогда
						ТекущаяЧасть = ТекущаяЧасть + Сред(ИсходнаяЧасть, Сч, 1);
					КонецЕсли;
				КонецЦикла;
			Иначе
				ТекущаяЧасть = ТекущаяЧасть + ИсходнаяЧасть;
			КонецЕсли;
			
			РазделителиСтрокой = РазделителиСтрокой + ТекущаяЧасть; 
		КонецЦикла;
		
		РазделителиСтрокой = РазделителиСтрокой + ")";
		
	Иначе
		РазделителиСтрокой = "";
	КонецЕсли;
	
	ИмяКлона = ОригинальныйПользователь.Имя + "_ТЦ" + Формат(Номер, "ЧЦ=6; ЧВН=; ЧГ=0") + РазделителиСтрокой;
	
	Если СтрДлина(ИмяКлона) > 256 Тогда
		ИмяКлона = Строка(ОригинальныйПользователь.УникальныйИдентификатор) + "_ТЦ" + Формат(Номер, "ЧЦ=6; ЧВН=; ЧГ=0");
	КонецЕсли;
	
	Возврат ИмяКлона;
	
КонецФункции // ИмяКлона()

// Возвращает представление элемента справочника ТЦКлиенты
//
// Параметры
//   Клиент - СправочникСсылка.ТЦКлиенты, СправочникОбъект.ТЦКлиенты
//
Функция ПолучитьПредставлениеКлиента(Клиент) Экспорт
	
	Представление = СокрЛП(Клиент.Компьютер);
	АдресБраузера = СокрЛП(Клиент.АдресБраузера);
	
	Если ЗначениеЗаполнено(Клиент.ТипКлиента) Тогда
		
		Если Клиент.ТипКлиента = Перечисления.ТЦТипКлиента.Веб Тогда
			Если Клиент.ТипБраузера <> Перечисления.ТЦТипБраузера.ПоУмолчанию Тогда
				Представление = Представление + ", " + Клиент.ТипБраузера;
			Иначе
				Представление = Представление + ", браузер по-умолчанию";
			КонецЕсли;
			
			Если ЗначениеЗаполнено(АдресБраузера) Тогда
				Представление = Представление + ", " + АдресБраузера;
			КонецЕсли;
			
		ИначеЕсли Клиент.ТипКлиента = Перечисления.ТЦТипКлиента.ТонкийВеб Тогда
			Представление = Представление + ", " + СокрЛП(Клиент.ТипКлиента);
			
			Если ЗначениеЗаполнено(АдресБраузера) Тогда
				Представление = Представление + ", " + АдресБраузера;
			КонецЕсли;
		Иначе
			Представление = Представление + ", " + СокрЛП(Клиент.ТипКлиента);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

// Возвращает кодированную строку
//
Функция КодироватьСтрокуВURL(Знач Текст) Экспорт
	
	Возврат Вычислить("КодироватьСтроку(Текст, СпособКодированияСтроки.КодировкаURL)");
	
КонецФункции

// Возвращает кодированную строку
//
Функция КодироватьСтрокуURLВURL(Знач Текст) Экспорт
	
	Возврат Вычислить("КодироватьСтроку(Текст, СпособКодированияСтроки.URLВКодировкеURL)");
	
КонецФункции
